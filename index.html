<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>ëª¨ë„¤ ì¸í„°ë™í‹°ë¸Œ ë…¸ë˜ì±… (Re-Design)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" />
<style>
:root {
  --primary: #9b72cf;
  --primary-light: #e0cffc;
  --accent: #ff9f43;
  --accent-soft: #ffeaa7;

  --glass-bg: rgba(255, 255, 255, 0.65);
  --glass-border: rgba(255, 255, 255, 0.8);
  --glass-shadow: 0 8px 32px 0 rgba(142, 114, 207, 0.15);

  --text-main: #2d3436;
  --text-sub: #636e72;

  --scale: 1;
  --page-max: calc(1600px * var(--scale));

  --col-manual: clamp(380px, 26vw, 560px);
  --col-book:   clamp(500px, 40vw, 780px);
  --col-req:    clamp(380px, 28vw, 500px);
  --gap-layout: 24px;

  --sheet-grid: rgba(185, 185, 185, 0.65);
}

* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
  color: var(--text-main);
  background: linear-gradient(-45deg, #ffecd2, #fcb69f, #e0c3fc, #8ec5fc);
  background-size: 400% 400%;
  animation: gradientBG 15s ease infinite;
  min-height: 100vh;
  overflow-x: hidden;
}

@keyframes gradientBG {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: rgba(255,255,255,0.3); border-radius: 4px; }
::-webkit-scrollbar-thumb { background: rgba(155, 114, 207, 0.5); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: rgba(155, 114, 207, 0.8); }

main {
  max-width: var(--page-max);
  margin: 0 auto;
  padding: 20px 20px 40px;
}

.header {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 24px;
  padding: 0 10px;
}

.title-wrap h1 {
  font-size: 28px;
  font-weight: 800;
  margin: 0;
  background: linear-gradient(135deg, #6c5ce7, #a29bfe);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 2px 10px rgba(162, 155, 254, 0.3);
  letter-spacing: -0.5px;
}

.title-row { display: flex; align-items: center; gap: 10px; margin-bottom: 4px; }

.badge {
  font-size: 11px;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 20px;
  background: #fff;
  color: var(--primary);
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  border: 1px solid rgba(255,255,255,0.5);
}

.subtitle { font-size: 14px; color: var(--text-sub); opacity: 0.9; }

.header-right { display: flex; gap: 8px; align-items: center; }
.status-pill {
  font-size: 12px;
  font-weight: 500;
  padding: 6px 14px;
  border-radius: 30px;
  background: rgba(255, 255, 255, 0.6);
  border: 1px solid #fff;
  backdrop-filter: blur(4px);
  display: flex; align-items: center; gap: 6px;
  color: var(--text-sub);
  box-shadow: 0 2px 6px rgba(0,0,0,0.03);
}
.status-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: #00b894;
  box-shadow: 0 0 6px #00b894;
}

.mini-btn {
  border: none;
  border-radius: 999px;
  padding: 5px 10px;
  font-size: 11px;
  font-weight: 800;
  cursor: pointer;
  background: rgba(255,255,255,0.9);
  color: var(--primary);
  border: 1px solid rgba(155,114,207,0.25);
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
.mini-btn:hover { transform: translateY(-1px); }
.mini-btn:active { transform: translateY(0px); }

.layout {
  display: grid;
  grid-template-columns: var(--col-manual) var(--col-book) var(--col-req);
  gap: var(--gap-layout);
  align-items: start;
  justify-content: center;
}

@media (max-width: 1200px) {
  .layout { grid-template-columns: 1fr 1fr; }
  .layout > .card:nth-child(1) { grid-row: span 2; }
}
@media (max-width: 900px) {
  .layout { grid-template-columns: 1fr; }
  .layout > .card:nth-child(1) { grid-row: auto; order: 2; }
  .layout > .card:nth-child(2) { order: 1; }
  .layout > .card:nth-child(3) { order: 3; }
}

.card {
  background: var(--glass-bg);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid var(--glass-border);
  border-radius: 24px;
  padding: 20px;
  box-shadow: var(--glass-shadow);
  display: flex;
  flex-direction: column;
  transition: transform 0.2s ease;
  min-height: 500px;
}
@media (min-width: 901px) {
  .layout > .card:first-child {
    position: sticky; top: 20px; z-index: 10;
    max-height: calc(100vh - 40px);
    overflow: hidden;
  }
}

.card-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 16px; padding-bottom: 12px;
  border-bottom: 1px solid rgba(0,0,0,0.05);
}
.card-title {
  font-size: 18px; font-weight: 700; color: #2d3436;
  display: flex; align-items: center; gap: 8px;
}
.card-sub {
  font-size: 13px; color: var(--text-sub); margin: -10px 0 16px 0; line-height: 1.4;
}

.controls {
  display: flex; flex-wrap: wrap; gap: 8px;
  margin-bottom: 16px;
  background: rgba(255,255,255,0.4);
  padding: 8px; border-radius: 16px;
}

.input, .select {
  padding: 8px 16px;
  border-radius: 20px;
  border: 1px solid rgba(255,255,255,0.8);
  background: rgba(255,255,255,0.8);
  font-family: inherit; font-size: 13px;
  outline: none;
  transition: all 0.2s;
  flex-grow: 1;
}
.input:focus, .select:focus {
  background: #fff;
  box-shadow: 0 0 0 3px rgba(155, 114, 207, 0.2);
  border-color: var(--primary);
}

.btn {
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-size: 13px; font-weight: 700;
  cursor: pointer;
  background: linear-gradient(135deg, var(--primary), #a29bfe);
  color: #fff;
  box-shadow: 0 4px 10px rgba(108, 92, 231, 0.3);
  transition: transform 0.1s, box-shadow 0.2s;
}
.btn:hover { transform: translateY(-2px); box-shadow: 0 6px 14px rgba(108, 92, 231, 0.4); }
.btn:active { transform: translateY(0); }

.toggle-group {
  display: inline-flex;
  background: rgba(255,255,255,0.5);
  border-radius: 20px;
  padding: 3px;
  border: 1px solid rgba(255,255,255,0.6);
}
.toggle {
  padding: 6px 14px;
  border-radius: 16px;
  font-size: 12px; font-weight: 600;
  color: var(--text-sub);
  cursor: pointer;
  transition: all 0.2s;
}
.toggle.active {
  background: #fff;
  color: var(--primary);
  box-shadow: 0 2px 6px rgba(0,0,0,0.05);
}

/* âœ… xì¶• ë“œë˜ê·¸/ê°€ë¡œ ìŠ¤í¬ë¡¤ ìœ ë°œ ë²„ê·¸ ë°©ì§€ */
.list {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 4px;
  scroll-behavior: smooth;
  min-height: 300px;
  max-height: 60vh;
  touch-action: pan-y;
  overscroll-behavior: contain;
}

.song-row {
  position: relative;
  display: flex; align-items: center; justify-content: space-between;
  padding: 12px 16px;
  margin-bottom: 8px;
  border-radius: 16px;
  background: rgba(255, 255, 255, 0.7);
  border: 1px solid transparent;
  transition: all 0.2s ease;
  gap: 12px;
  touch-action: pan-y;
}
.song-row:hover {
  background: rgba(255, 255, 255, 0.95);
  transform: scale(1.01) translateX(2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.05);
}

.song-row.requested {
  background: linear-gradient(to right, #fffcf2, #fff);
  border-left: 4px solid var(--accent);
  box-shadow: 0 4px 12px rgba(255, 159, 67, 0.15);
}

.song-main { flex: 1; min-width: 0; }
.song-title {
  font-size: 15px; font-weight: 700; color: #2d3436;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  margin-bottom: 4px;
}
.song-meta { display: flex; flex-wrap: wrap; gap: 6px; font-size: 12px; color: var(--text-sub); }

.tag {
  background: rgba(108, 92, 231, 0.1);
  color: #6c5ce7;
  padding: 2px 8px;
  border-radius: 6px;
  font-size: 11px; font-weight: 600;
}

.song-actions { display: flex; flex-direction: column; align-items: flex-end; gap: 6px; }

.song-btn {
  background: rgba(0,0,0,0.03);
  border: 1px solid rgba(0,0,0,0.05);
  color: #636e72;
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 11px; cursor: pointer;
  transition: all 0.2s;
}
.song-btn:hover { background: var(--primary); color: #fff; border-color: var(--primary); }

.song-status-pill {
  font-size: 10px; font-weight: 700;
  padding: 2px 8px; border-radius: 10px;
  background: #dfe6e9; color: #636e72;
}
.requested .song-status-pill { background: #ffeaa7; color: #e17055; }

body.compact-mode .song-row { padding: 8px 12px; }
body.compact-mode .song-meta { display: none; }

.now-playing {
  margin-bottom: 16px;
  padding: 20px;
  border-radius: 20px;
  background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
  color: #2d3436;
  box-shadow: 0 8px 20px rgba(250, 177, 160, 0.4);
  position: relative;
  overflow: hidden;
  border: none;
}
.now-playing::before {
  content: "â™«";
  position: absolute; right: -10px; bottom: -20px;
  font-size: 100px; opacity: 0.2; color: #fff; transform: rotate(-20deg);
}

.now-playing.empty {
  background: rgba(255,255,255,0.5);
  border: 2px dashed rgba(0,0,0,0.1);
  box-shadow: none;
  opacity: 1;
}

.now-playing-label {
  font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
  font-weight: 800; opacity: 0.7; margin-bottom: 8px;
}
.now-playing-title {
  font-size: 18px; font-weight: 800;
  margin-bottom: 4px;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  position: relative; z-index: 1;
}
.now-playing-meta {
  font-size: 13px; opacity: 0.8; margin-bottom: 12px;
  position: relative; z-index: 1;
}
#nowPlayingDoneBtn {
  background: #fff; color: #e17055; border: none;
  padding: 6px 14px; border-radius: 12px; font-weight: 700;
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  position: relative; z-index: 1; cursor: pointer;
}
#nowPlayingDoneBtn:disabled { opacity: 0.5; cursor: default; box-shadow: none; }

.empty {
  text-align: center; padding: 40px 20px;
  color: var(--text-sub); font-size: 14px;
  background: rgba(255,255,255,0.3); border-radius: 16px;
}

footer {
  text-align: center; margin-top: 40px; font-size: 12px;
  color: rgba(0,0,0,0.4);
}

/* MANUAL */
#manualList {
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 6px;
  touch-action: pan-y;
}
.manual-sheet-wrap {
  border-radius: 12px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  border: 1px solid rgba(0,0,0,0.1);
}
table.manual-sheet {
  border-collapse: collapse;
  table-layout: fixed;
  background: #fff;
}
table.manual-sheet td {
  border: 1px solid var(--sheet-grid);
  padding: 4px 6px;
  font-size: 12px;
  line-height: 1.25;
  vertical-align: top;
  white-space: pre-wrap;
  word-break: break-word;
}

/* =========================
   âœ… ë¡œê·¸ì¸ ëª¨ë‹¬
   ========================= */
.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  display: none;
  align-items: center;
  justify-content: center;
  padding: 18px;
  z-index: 9999;
}
.modal {
  width: min(420px, 100%);
  background: rgba(255,255,255,0.92);
  backdrop-filter: blur(18px);
  border: 1px solid rgba(255,255,255,0.9);
  border-radius: 18px;
  box-shadow: 0 18px 60px rgba(0,0,0,0.18);
  overflow: hidden;
}
.modal-header {
  padding: 14px 16px;
  border-bottom: 1px solid rgba(0,0,0,0.06);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}
.modal-title {
  font-size: 14px;
  font-weight: 900;
  color: #2d3436;
}
.modal-body {
  padding: 14px 16px;
}
.modal-row {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 12px;
}
.modal-label {
  font-size: 12px;
  font-weight: 800;
  color: var(--text-sub);
}
.modal-input {
  width: 100%;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(0,0,0,0.12);
  outline: none;
  font-size: 13px;
  background: rgba(255,255,255,0.95);
}
.modal-input:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(155,114,207,0.18);
}
.modal-hint {
  font-size: 12px;
  color: rgba(0,0,0,0.55);
  line-height: 1.35;
}
.modal-error {
  display: none;
  margin-top: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  background: rgba(255,118,117,0.12);
  border: 1px solid rgba(255,118,117,0.25);
  color: rgba(180, 60, 60, 1);
  font-size: 12px;
  font-weight: 800;
}
.modal-footer {
  padding: 14px 16px;
  border-top: 1px solid rgba(0,0,0,0.06);
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}
.modal-btn {
  border: none;
  border-radius: 12px;
  padding: 10px 14px;
  font-size: 12px;
  font-weight: 900;
  cursor: pointer;
}
.modal-btn.cancel {
  background: rgba(0,0,0,0.06);
  color: rgba(0,0,0,0.65);
}
.modal-btn.ok {
  background: linear-gradient(135deg, var(--primary), #a29bfe);
  color: #fff;
  box-shadow: 0 8px 22px rgba(108,92,231,0.25);
}
</style>
</head>
<body>
<main>

<header class="header">
  <div class="title-wrap">
    <div class="title-row">
      <h1>âœ¨ ëª¨ë„¤ ë…¸ë˜ì±… ë·°ì–´</h1>
      <span class="badge">Live Sync</span>
    </div>
    <div class="subtitle">
      ì¦ê±°ìš´ ë°©ì†¡ì„ ìœ„í•œ ì‹ ì²­ê³¡ ê´€ë¦¬ ë§¤ë‹ˆì € ğŸµ
    </div>
  </div>

  <div class="header-right">
    <div class="status-pill">
      <span class="status-dot"></span>
      <span>System: <b id="authStatusText">Locked</b></span>
    </div>

    <div class="status-pill">
      Data: <b id="sheetStatus">ë¡œë”© ì¤‘...</b>
      <button class="mini-btn" id="loginBtn" type="button">ë¡œê·¸ì¸</button>
      <button class="mini-btn" id="pwChangeBtn" type="button" style="display:none;">ë¹„ë²ˆ ë³€ê²½</button>
      <button class="mini-btn" id="logoutBtn" type="button" style="display:none;">ë¡œê·¸ì•„ì›ƒ</button>
    </div>
  </div>
</header>

<section class="layout">

  <section class="card">
    <div class="card-header">
      <div class="card-title">ğŸ“˜ ì´ìš© ê°€ì´ë“œ</div>
      <div class="badge">Manual</div>
    </div>
    <div id="manualList">
      <div class="empty">ì„¤ëª…ì„œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤â€¦</div>
    </div>
  </section>

  <section class="card">
    <div class="card-header">
      <div class="card-title">ğŸµ ë…¸ë˜ ëª©ë¡</div>
      <div class="badge" style="background:var(--primary-light); color:var(--primary)">Auto Load</div>
    </div>
    <p class="card-sub">
      Google Sheetì—ì„œ ë°ì´í„°ë¥¼ ìë™ìœ¼ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤. (30ì´ˆ ì£¼ê¸° ê°±ì‹ )
    </p>

    <div class="controls">
      <input class="input" type="text"
        placeholder="ğŸ” ê³¡ëª…, ê°€ìˆ˜, íƒœê·¸ ê²€ìƒ‰..."
        id="searchInput" />

      <select class="select" id="filterSelect" style="max-width:180px;">
        <optgroup label="ìƒíƒœ">
          <option value="all" selected>ì „ì²´ ë³´ê¸°</option>
          <option value="unrequested">ë¯¸ì‹ ì²­ ê³¡</option>
          <option value="requested">ì‹ ì²­ëœ ê³¡</option>
        </optgroup>
        <optgroup label="ì¹´í…Œê³ ë¦¬" id="categoryOptGroup">
          <option value="cat:__all__">ì¹´í…Œê³ ë¦¬: ì „ì²´</option>
        </optgroup>
      </select>

      <div class="toggle-group" id="viewToggle">
        <div class="toggle active" data-mode="list">ê¸°ë³¸</div>
        <div class="toggle" data-mode="compact">ì‘ê²Œ</div>
      </div>
      <button class="btn" id="reloadBtn">â†» ìƒˆë¡œê³ ì¹¨</button>
    </div>

    <div class="list" id="songList"></div>
    <div class="empty" id="songEmptyMessage" style="display:none;">
      ë…¸ë˜ì±… ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. <br> ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.
    </div>
  </section>

  <section class="card">
    <div class="card-header">
      <div class="card-title">ğŸ’Œ ì‹ ì²­ê³¡ ë¦¬ìŠ¤íŠ¸</div>
      <div class="badge" style="background:var(--accent-soft); color:#e17055">Request</div>
    </div>

    <div class="now-playing empty" id="nowPlayingCard">
      <div class="now-playing-label">Now Playing</div>
      <div class="now-playing-title" id="nowPlayingTitle">ì„ íƒëœ ê³¡ ì—†ìŒ</div>
      <div class="now-playing-meta" id="nowPlayingMeta">
        ëŒ€ê¸° ëª©ë¡ì—ì„œ 'ì§€ê¸ˆ ë¶€ë¥´ê¸°'ë¥¼ ì„ íƒí•˜ì„¸ìš”.
      </div>
      <button id="nowPlayingDoneBtn" disabled>ë…¸ë˜ ì™„ë£Œ</button>
    </div>

    <div class="controls" style="justify-content: space-between;">
      <div class="toggle-group" id="requestTabToggle">
        <div class="toggle active" data-tab="pending">ëŒ€ê¸° ì¤‘</div>
        <div class="toggle" data-tab="done">ì™„ë£Œë¨</div>
      </div>
      <button class="btn" id="clearRequestsBtn" style="background:#ff7675; box-shadow:0 4px 10px rgba(255,118,117,0.3)">ì´ˆê¸°í™”</button>
    </div>

    <div class="list" id="requestList"></div>
    <div class="empty" id="requestEmptyMessage">
      ì•„ì§ ì‹ ì²­ëœ ê³¡ì´ ì—†ì–´ìš”. <br>ë“£ê³  ì‹¶ì€ ë…¸ë˜ë¥¼ ì‹ ì²­í•´ë³´ì„¸ìš”!
    </div>
  </section>

</section>

<footer>
  MONE Interactive Songbook Viewer &copy; 2024
</footer>

</main>

<!-- âœ… AUTH MODAL -->
<div class="modal-backdrop" id="authModalBackdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="authModalTitle">
    <div class="modal-header">
      <div class="modal-title" id="authModalTitle">ê´€ë¦¬ì ì¸ì¦</div>
      <button class="mini-btn" id="authModalCloseBtn" type="button">ë‹«ê¸°</button>
    </div>

    <div class="modal-body">
      <div class="modal-hint" id="authModalHint">
        ë²„íŠ¼(ì‹ ì²­/ì·¨ì†Œ/ì§€ê¸ˆë¶€ë¥´ê¸°/ì´ˆê¸°í™”/ë…¸ë˜ì™„ë£Œ)ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë¹„ë°€ë²ˆí˜¸ê°€ í•„ìš”í•©ë‹ˆë‹¤.
      </div>

      <!-- LOGIN FORM -->
      <div id="loginForm">
        <div class="modal-row">
          <div class="modal-label">ë¹„ë°€ë²ˆí˜¸</div>
          <input class="modal-input" id="loginPassword" type="password" autocomplete="current-password" placeholder="ë¹„ë°€ë²ˆí˜¸ ì…ë ¥" />
        </div>
      </div>

      <!-- CHANGE PW FORM -->
      <div id="changePwForm" style="display:none;">
        <div class="modal-row">
          <div class="modal-label">í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ (ë˜ëŠ” ë§ˆìŠ¤í„°)</div>
          <input class="modal-input" id="currentPassword" type="password" autocomplete="current-password" placeholder="í˜„ì¬ ë¹„ë°€ë²ˆí˜¸" />
        </div>
        <div class="modal-row">
          <div class="modal-label">ìƒˆ ë¹„ë°€ë²ˆí˜¸</div>
          <input class="modal-input" id="newPassword" type="password" autocomplete="new-password" placeholder="ìƒˆ ë¹„ë°€ë²ˆí˜¸ (4~64ì)" />
        </div>
        <div class="modal-row">
          <div class="modal-label">ìƒˆ ë¹„ë°€ë²ˆí˜¸ í™•ì¸</div>
          <input class="modal-input" id="newPassword2" type="password" autocomplete="new-password" placeholder="í•œ ë²ˆ ë” ì…ë ¥" />
        </div>
      </div>

      <div class="modal-error" id="authModalError">ì—ëŸ¬</div>
    </div>

    <div class="modal-footer">
      <button class="modal-btn cancel" id="authCancelBtn" type="button">ì·¨ì†Œ</button>
      <button class="modal-btn ok" id="authOkBtn" type="button">í™•ì¸</button>
    </div>
  </div>
</div>

<script>
  const state = {
    songs: [],
    filter: "all",
    search: "",
    viewMode: "list",
    requestTab: "pending",
    nowPlayingId: null,
    nextRequestOrder: 1,
    loading: false,

    // âœ… auth
    authenticated: false,
    authMode: "login", // login | change
    pendingAction: null,
  };

  // ===== ìœ í‹¸ =====
  function normalizeText(str) {
    if (!str) return "";
    return String(str).toLowerCase().trim();
  }

  function songKey(song) {
    return normalizeText(song.title) + "|" + normalizeText(song.artistRaw);
  }

  function getCookie(name) {
    const m = document.cookie.match(new RegExp("(^|; )" + name.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "=([^;]*)"));
    return m ? decodeURIComponent(m[2]) : "";
  }

  function authHeaders(extra = {}) {
    const csrf = getCookie("mone_csrf");
    const h = { ...extra };
    if (csrf) h["X-CSRF-Token"] = csrf;
    return h;
  }

  async function authFetch(url, opts = {}) {
    const o = { ...opts };
    o.credentials = "include";
    o.headers = { ...(opts.headers || {}) };
    return fetch(url, o);
  }

  function setAuthUI(isAuthed) {
    state.authenticated = !!isAuthed;
    const t = document.getElementById("authStatusText");
    const loginBtn = document.getElementById("loginBtn");
    const pwBtn = document.getElementById("pwChangeBtn");
    const logoutBtn = document.getElementById("logoutBtn");

    if (t) t.textContent = isAuthed ? "Ready" : "Locked";
    if (loginBtn) loginBtn.style.display = isAuthed ? "none" : "inline-flex";
    if (pwBtn) pwBtn.style.display = isAuthed ? "inline-flex" : "none";
    if (logoutBtn) logoutBtn.style.display = isAuthed ? "inline-flex" : "none";
  }

  async function checkAuth() {
    try {
      const r = await authFetch("/api/auth/me", { method: "GET" });
      const j = await r.json().catch(() => null);
      setAuthUI(!!j?.authenticated);
      return !!j?.authenticated;
    } catch (_) {
      setAuthUI(false);
      return false;
    }
  }

  function openAuthModal(mode) {
    state.authMode = mode || "login";

    const bd = document.getElementById("authModalBackdrop");
    const title = document.getElementById("authModalTitle");
    const hint = document.getElementById("authModalHint");
    const err = document.getElementById("authModalError");

    const loginForm = document.getElementById("loginForm");
    const changeForm = document.getElementById("changePwForm");

    if (err) { err.style.display = "none"; err.textContent = ""; }

    if (state.authMode === "login") {
      if (title) title.textContent = "ê´€ë¦¬ì ì¸ì¦";
      if (hint) hint.textContent = "ë²„íŠ¼(ì‹ ì²­/ì·¨ì†Œ/ì§€ê¸ˆë¶€ë¥´ê¸°/ì´ˆê¸°í™”/ë…¸ë˜ì™„ë£Œ)ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë¹„ë°€ë²ˆí˜¸ê°€ í•„ìš”í•©ë‹ˆë‹¤.";
      if (loginForm) loginForm.style.display = "block";
      if (changeForm) changeForm.style.display = "none";
      const inp = document.getElementById("loginPassword");
      if (inp) { inp.value = ""; setTimeout(() => inp.focus(), 10); }
    } else {
      if (title) title.textContent = "ë¹„ë°€ë²ˆí˜¸ ë³€ê²½";
      if (hint) hint.textContent = "í˜„ì¬ ë¹„ë°€ë²ˆí˜¸(ë˜ëŠ” ë§ˆìŠ¤í„°)ë¡œ í™•ì¸ í›„ ìƒˆ ë¹„ë°€ë²ˆí˜¸ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.";
      if (loginForm) loginForm.style.display = "none";
      if (changeForm) changeForm.style.display = "block";
      const a = document.getElementById("currentPassword");
      const b = document.getElementById("newPassword");
      const c = document.getElementById("newPassword2");
      if (a) a.value = "";
      if (b) b.value = "";
      if (c) c.value = "";
      if (a) setTimeout(() => a.focus(), 10);
    }

    if (bd) bd.style.display = "flex";
    if (bd) bd.setAttribute("aria-hidden", "false");
  }

  function closeAuthModal() {
    const bd = document.getElementById("authModalBackdrop");
    if (bd) bd.style.display = "none";
    if (bd) bd.setAttribute("aria-hidden", "true");
  }

  function showAuthError(msg) {
    const err = document.getElementById("authModalError");
    if (!err) return;
    err.textContent = msg || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
    err.style.display = "block";
  }

  async function doLogin(password) {
    try {
      const r = await authFetch("/api/auth/login", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ password }),
      });

      const j = await r.json().catch(() => null);

      if (!r.ok || !j?.authenticated) {
        return { ok: false };
      }

      setAuthUI(true);
      return { ok: true };
    } catch (_) {
      return { ok: false };
    }
  }

  async function doLogout() {
    try {
      const r = await authFetch("/api/auth/logout", {
        method: "POST",
        headers: authHeaders({ "content-type": "application/json" }),
        body: JSON.stringify({}),
      });
      const j = await r.json().catch(() => null);
      if (!r.ok || !j?.ok) return false;
      setAuthUI(false);
      return true;
    } catch (_) {
      return false;
    }
  }

  async function doChangePassword(currentPassword, newPassword) {
    try {
      const r = await authFetch("/api/auth/change-password", {
        method: "POST",
        headers: authHeaders({ "content-type": "application/json" }),
        body: JSON.stringify({ currentPassword, newPassword }),
      });
      const j = await r.json().catch(() => null);
      if (!r.ok || !j?.ok) return { ok: false, code: j?.error || "fail" };
      return { ok: true };
    } catch (_) {
      return { ok: false, code: "network" };
    }
  }

  // âœ… async actionë„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
  async function requireAuthThen(actionFn) {
    const ok = await checkAuth();
    if (ok) return Promise.resolve(actionFn());

    state.pendingAction = actionFn;
    openAuthModal("login");
  }

  // âœ… xì¶• ë“œë˜ê·¸(íœ  ì¢Œìš° ìŠ¤í¬ë¡¤) ì°¨ë‹¨
  function blockHorizontalWheel(el) {
    if (!el) return;
    el.addEventListener("wheel", (e) => {
      if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
        e.preventDefault();
      }
    }, { passive: false });
  }

  // ===== API ë¡œë”© =====
  const API_URL = "/api/songbook";
  const QUEUE_URL = "/api/queue";

  function coalesce(obj, keys) {
    for (const k of keys) {
      const v = obj?.[k];
      if (v != null && String(v).trim() !== "") return String(v);
    }
    return "";
  }

  function normalizeTags(v) {
    if (Array.isArray(v)) return v.map(x => String(x).trim()).filter(Boolean);
    if (!v) return [];
    return String(v).split(/[;,]/).map(x => x.trim()).filter(Boolean);
  }

  function splitArtists(artistRaw) {
    const s = String(artistRaw ?? "").trim();
    if (!s) return [];
    // "ìš”ì•„ë¦¬, ê¹€ë¯¼í˜¸" -> ["ìš”ì•„ë¦¬", "ê¹€ë¯¼í˜¸"]
    return s.split(",").map(x => x.trim()).filter(Boolean);
  }

  function apiSongToSong(item, idx) {
    const title = coalesce(item, ["title","ê³¡ëª…","ì œëª©","song","Song","Title"]);
    const artistRaw = coalesce(item, ["artist","ê°€ìˆ˜","ì•„í‹°ìŠ¤íŠ¸","singer","Artist"]);
    const lang = coalesce(item, ["lang","language","ì–¸ì–´","Lang"]);
    const url = coalesce(item, ["url","link","youtube","ìœ íŠœë¸Œ","ë§í¬","URL"]);
    const category = coalesce(item, ["category","ì¹´í…Œê³ ë¦¬","ë¶„ë¥˜","Category"]);
    const flag = coalesce(item, ["flag","Flag","í‘œì‹œ","mark","Mark"]);
    const tags = normalizeTags(item?.tags ?? item?.tag ?? item?.genre ?? item?.ì¥ë¥´ ?? item?.ë¶„ë¥˜);

    const artistTags = splitArtists(artistRaw);
    const flagTags = flag ? [flag] : [];

    const raw = (item?.raw && typeof item.raw === "object") ? item.raw : { ...item };

    return {
      id: idx,
      title,
      artistRaw,
      artistTags,
      lang,
      url,
      category,
      tags,
      flagTags,
      requestStatus: "none",
      requestOrder: null,
      raw,
    };
  }

  function updateSheetStatus(text) {
    const el = document.getElementById("sheetStatus");
    if (el) el.textContent = text;
  }

  // ==========================
  // âœ… ì„œë²„ ì €ì¥ í(ì‹ ì²­ê³¡) ì ìš©
  // ==========================
  function applyQueueToState(queue) {
    const items = queue?.items && typeof queue.items === "object" ? queue.items : {};
    const nowKey = String(queue?.nowPlayingKey ?? "") || null;

    state.songs.forEach((s) => {
      const k = songKey(s);
      const it = items[k];
      if (!it) {
        s.requestStatus = "none";
        s.requestOrder = null;
        return;
      }
      s.requestStatus = it.status === "done" ? "done" : "pending";
      s.requestOrder = Number(it.order ?? null);
    });

    if (nowKey) {
      const np = state.songs.find((s) => songKey(s) === nowKey);
      state.nowPlayingId = np ? np.id : null;
    } else {
      state.nowPlayingId = null;
    }

    state.nextRequestOrder = Number(queue?.nextOrder ?? state.nextRequestOrder ?? 1) || 1;
  }

  async function loadQueueOnce() {
    try {
      const r = await fetch(QUEUE_URL, { cache: "no-store" });
      const j = await r.json().catch(() => null);
      if (r.ok && j?.ok) {
        applyQueueToState(j.queue);
        renderAll(); // ë‹¤ë¥¸ ê¸°ê¸° ë³€ê²½ë„ ë¹ ë¥´ê²Œ ë°˜ì˜
      }
    } catch (_) {}
  }

  async function queueAction(type, key = "") {
    const r = await authFetch("/api/queue/action", {
      method: "POST",
      headers: authHeaders({ "content-type": "application/json" }),
      body: JSON.stringify({ type, key }),
    });
    const j = await r.json().catch(() => null);
    if (!r.ok || !j?.ok) throw new Error(j?.error || "fail");
    applyQueueToState(j.queue);
  }

  // ===== âœ… í•„í„° ì˜µì…˜(ì¹´í…Œê³ ë¦¬) ë™ì  ìƒì„± =====
  function rebuildFilterOptions() {
    const select = document.getElementById("filterSelect");
    if (!select) return;

    const prev = String(select.value || "all");

    const set = new Set();
    state.songs.forEach((s) => {
      const c = String(s?.category ?? "").trim();
      if (c) set.add(c);
    });

    const categories = Array.from(set).sort((a, b) => a.localeCompare(b, "ko"));

    select.innerHTML = "";

    const ogState = document.createElement("optgroup");
    ogState.label = "ìƒíƒœ";

    const optAll = document.createElement("option");
    optAll.value = "all";
    optAll.textContent = "ì „ì²´ ë³´ê¸°";
    ogState.appendChild(optAll);

    const optUn = document.createElement("option");
    optUn.value = "unrequested";
    optUn.textContent = "ë¯¸ì‹ ì²­ ê³¡";
    ogState.appendChild(optUn);

    const optReq = document.createElement("option");
    optReq.value = "requested";
    optReq.textContent = "ì‹ ì²­ëœ ê³¡";
    ogState.appendChild(optReq);

    select.appendChild(ogState);

    const ogCat = document.createElement("optgroup");
    ogCat.label = "ì¹´í…Œê³ ë¦¬";

    const optCatAll = document.createElement("option");
    optCatAll.value = "cat:__all__";
    optCatAll.textContent = "ì¹´í…Œê³ ë¦¬: ì „ì²´";
    ogCat.appendChild(optCatAll);

    categories.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = "cat:" + c;
      opt.textContent = c;
      ogCat.appendChild(opt);
    });

    select.appendChild(ogCat);

    const exists = Array.from(select.options).some(o => o.value === prev);
    select.value = exists ? prev : "all";
    state.filter = select.value;
  }

  // ===== âœ… ì„¤ëª…ì„œ: manualGridë¥¼ "ì‹œíŠ¸ì²˜ëŸ¼" ê·¸ë¦¬ê¸° (ë¡œì§ ìœ ì§€) =====
  const MANUAL_ZOOM = 1.18;

  function mulPx_(v, k) {
    const n = parseFloat(String(v ?? "").replace("px", ""));
    if (!isFinite(n)) return null;
    return `${Math.max(1, Math.round(n * k))}px`;
  }

  function mulPadding_(pad, k) {
    const parts = String(pad ?? "").trim().split(/\s+/);
    if (!parts.length) return null;
    const out = parts.map(p => mulPx_(p, k) ?? p);
    return out.join(" ");
  }

  function applyCellStyle(td, style) {
    if (!style || typeof style !== "object") return;

    const defaultBorder =
      getComputedStyle(document.documentElement)
        .getPropertyValue("--sheet-grid")
        .trim() || "rgba(185,185,185,0.65)";

    if (style.background) td.style.background = style.background;
    if (style.color) td.style.color = style.color;

    if (style.fontSize) td.style.fontSize = mulPx_(style.fontSize, MANUAL_ZOOM) || style.fontSize;

    if (style.fontWeight) td.style.fontWeight = style.fontWeight;
    if (style.fontStyle) td.style.fontStyle = style.fontStyle;
    if (style.textAlign) td.style.textAlign = style.textAlign;
    if (style.verticalAlign) td.style.verticalAlign = style.verticalAlign;

    const ws = style.whiteSpace;
    td.style.whiteSpace = (ws === "pre" ? "pre-wrap" : (ws || "pre-wrap"));
    td.style.wordBreak = "break-word";
    td.style.overflow = "visible";
    td.style.textOverflow = "clip";
    td.style.lineHeight = "1.25";

    if (style.padding) td.style.padding = mulPadding_(style.padding, MANUAL_ZOOM) || style.padding;

    td.style.borderTop    = style.borderTop    || `1px solid ${defaultBorder}`;
    td.style.borderBottom = style.borderBottom || `1px solid ${defaultBorder}`;
    td.style.borderLeft   = style.borderLeft   || `1px solid ${defaultBorder}`;
    td.style.borderRight  = style.borderRight  || `1px solid ${defaultBorder}`;
  }

  function buildManualTableFromGrid(grid) {
    const rowsTotal = Math.max(0, Number(grid?.rows ?? 0));
    const colsTotal = Math.max(0, Number(grid?.cols ?? 0));
    const cells = Array.isArray(grid?.cells) ? grid.cells : [];

    const cellMap = new Map();
    const covered = new Set();

    for (const cell of cells) {
      const r = Number(cell?.r ?? 0);
      const c = Number(cell?.c ?? 0);
      const rs = Math.max(1, Number(cell?.rowSpan ?? 1));
      const cs = Math.max(1, Number(cell?.colSpan ?? 1));
      const key = `${r},${c}`;

      cellMap.set(key, {
        r, c,
        rowSpan: rs,
        colSpan: cs,
        text: cell?.text ?? "",
        style: cell?.style ?? {}
      });

      for (let rr = r; rr < r + rs; rr++) {
        for (let cc = c; cc < c + cs; cc++) {
          if (rr === r && cc === c) continue;
          covered.add(`${rr},${cc}`);
        }
      }
    }

    if (cellMap.size === 0) {
      const wrap = document.createElement("div");
      wrap.className = "manual-sheet-wrap";
      wrap.innerHTML = "<div class='empty' style='margin:10px;'>ì„¤ëª…ì„œ(ê·¸ë¦¬ë“œ)ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.</div>";
      return wrap;
    }

    const values = [...cellMap.values()];
    const textCells = values.filter(v => String(v?.text ?? "").trim() !== "");
    const basis = textCells.length ? textCells : values;

    let minR = Infinity, minC = Infinity, maxR = -1, maxC = -1;
    for (const v of basis) {
      minR = Math.min(minR, v.r);
      minC = Math.min(minC, v.c);
      maxR = Math.max(maxR, v.r + v.rowSpan - 1);
      maxC = Math.max(maxC, v.c + v.colSpan - 1);
    }

    const PAD_ROWS = 1;
    const PAD_COLS = 0;

    minR = Math.max(0, minR - PAD_ROWS);
    minC = Math.max(0, minC - PAD_COLS);
    maxR = Math.min(rowsTotal - 1, maxR + PAD_ROWS);
    maxC = Math.min(colsTotal - 1, maxC + PAD_COLS);

    const hasAnchorInCol = (col) => {
      for (const v of values) {
        const text = String(v?.text ?? "").trim();
        const st = v?.style ?? {};
        const hasStyle = !!(
          st.background || st.borderTop || st.borderBottom || st.borderLeft || st.borderRight ||
          (String(st.fontWeight ?? "") === "700") || st.color
        );

        const c0 = v.c;
        const c1 = v.c + (v.colSpan || 1) - 1;
        if (col >= c0 && col <= c1) {
          if (text || hasStyle) return true;
        }
      }
      return false;
    };

    const hasAnchorInRow = (row) => {
      for (const v of values) {
        const text = String(v?.text ?? "").trim();
        const st = v?.style ?? {};
        const hasStyle = !!(
          st.background || st.borderTop || st.borderBottom || st.borderLeft || st.borderRight ||
          (String(st.fontWeight ?? "") === "700") || st.color
        );

        const r0 = v.r;
        const r1 = v.r + (v.rowSpan || 1) - 1;
        if (row >= r0 && row <= r1) {
          if (text || hasStyle) return true;
        }
      }
      return false;
    };

    while (minC <= maxC && !hasAnchorInCol(minC)) minC++;
    while (minC <= maxC && !hasAnchorInCol(maxC)) maxC--;
    while (minR <= maxR && !hasAnchorInRow(minR)) minR++;
    while (minR <= maxR && !hasAnchorInRow(maxR)) maxR--;

    const wrap = document.createElement("div");
    wrap.className = "manual-sheet-wrap";

    const table = document.createElement("table");
    table.className = "manual-sheet";
    table.style.tableLayout = "fixed";

    const visibleCols = Math.max(1, (maxC - minC + 1));

    const EMPTY_MIN = 22;
    const TEXT_MIN  = 78;

    const score = new Array(visibleCols).fill(0);
    const hasText = new Array(visibleCols).fill(false);

    for (const v of values) {
      const text = String(v?.text ?? "").trim();
      if (!text) continue;

      const start = Math.max(minC, v.c);
      const end = Math.min(maxC, v.c + (v.colSpan || 1) - 1);
      const per = Math.ceil(text.length / Math.max(1, v.colSpan || 1));

      for (let c = start; c <= end; c++) {
        const idx = c - minC;
        hasText[idx] = true;
        score[idx] = Math.max(score[idx], per);
      }
    }

    const widths = new Array(visibleCols).fill(0);
    let baseSum = 0;
    for (let i = 0; i < visibleCols; i++) {
      widths[i] = hasText[i] ? TEXT_MIN : EMPTY_MIN;
      baseSum += widths[i];
    }

    const manualList = document.getElementById("manualList");
    const targetW = Math.max(320, (manualList?.clientWidth ?? 360) - 10);
    let remain = targetW - baseSum;

    if (remain > 0) {
      const wSum = score.reduce((a, b, i) => a + (hasText[i] ? Math.pow(Math.max(1, b), 0.8) : 0), 0);
      if (wSum > 0) {
        for (let i = 0; i < visibleCols; i++) {
          if (!hasText[i]) continue;
          const w = Math.pow(Math.max(1, score[i]), 0.8);
          widths[i] += Math.floor(remain * (w / wSum));
        }
      }
    }

    const colgroup = document.createElement("colgroup");
    for (let i = 0; i < visibleCols; i++) {
      const col = document.createElement("col");
      col.style.width = `${widths[i]}px`;
      colgroup.appendChild(col);
    }
    table.appendChild(colgroup);

    const sumW = widths.reduce((a, b) => a + b, 0);
    table.style.width = `${sumW}px`;
    table.style.minWidth = "100%";

    const tbody = document.createElement("tbody");

    for (let r = minR; r <= maxR; r++) {
      const tr = document.createElement("tr");

      for (let c = minC; c <= maxC; c++) {
        const key = `${r},${c}`;
        if (covered.has(key)) continue;

        const data = cellMap.get(key) || { text: "", style: {}, rowSpan: 1, colSpan: 1 };
        const td = document.createElement("td");

        if (data.rowSpan > 1) td.rowSpan = data.rowSpan;
        if (data.colSpan > 1) td.colSpan = data.colSpan;

        td.textContent = data.text ?? "";
        applyCellStyle(td, data.style);

        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    wrap.appendChild(table);
    return wrap;
  }

  function renderManual(manualGrid, manualFlat) {
    const list = document.getElementById("manualList");
    if (!list) return;

    list.innerHTML = "";

    if (manualGrid && manualGrid.rows && manualGrid.cols) {
      try {
        list.appendChild(buildManualTableFromGrid(manualGrid));
        return;
      } catch (e) {
        console.error("manualGrid render failed:", e);
      }
    }

    const manual = Array.isArray(manualFlat) ? manualFlat : [];
    if (manual.length === 0) {
      list.innerHTML = "<div class='empty'>ì„¤ëª…ì„œê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.</div>";
      return;
    }

    const wrap = document.createElement("div");
    wrap.className = "manual-sheet-wrap";

    const div = document.createElement("div");
    div.style.padding = "8px";

    manual.forEach((m) => {
      const line = document.createElement("div");
      const st = m?.style || {};
      line.textContent = m?.text ?? "";
      line.style.whiteSpace = "pre-wrap";
      line.style.padding = "4px 6px";
      line.style.border = "1px solid rgba(185,185,185,0.45)";
      line.style.borderRadius = "8px";
      line.style.marginBottom = "6px";
      line.style.background = st.background || "rgba(255,255,255,0.98)";
      if (st.fontSize) line.style.fontSize = st.fontSize + "px";
      if (st.bold) line.style.fontWeight = "700";
      if (st.color) line.style.color = st.color;
      div.appendChild(line);
    });

    wrap.appendChild(div);
    list.appendChild(wrap);
  }

  // ===== ì‹œíŠ¸ ë°ì´í„° ë¡œë”© =====
  async function loadSheet(showStatusText = true) {
    if (state.loading) return;
    state.loading = true;
    updateSheetStatus("ë™ê¸°í™” ì¤‘...");

    const songListEl = document.getElementById("songList");
    const songEmptyMessage = document.getElementById("songEmptyMessage");

    if (showStatusText) {
      songListEl.innerHTML = "<div class='empty'>ë¡œë”© ì¤‘...</div>";
      songEmptyMessage.style.display = "none";
    }

    try {
      const res = await fetch(API_URL);
      if (!res.ok) throw new Error("API HTTP " + res.status);

      const data = await res.json();
      const apiSongs = Array.isArray(data.songs) ? data.songs : [];

      const prevSongMap = new Map();
      state.songs.forEach((s) => prevSongMap.set(songKey(s), s));

      const prevNowKey =
        state.nowPlayingId != null
          ? songKey(state.songs.find((s) => s.id === state.nowPlayingId) || {})
          : null;

      const songs = apiSongs
        .map((item, idx) => apiSongToSong(item, idx))
        .filter((s) => s.title && s.title.trim());

      songs.forEach((s) => {
        const prev = prevSongMap.get(songKey(s));
        if (prev) {
          s.requestStatus = prev.requestStatus;
          s.requestOrder = prev.requestOrder;
        }
      });

      state.songs = songs;

      if (prevNowKey) {
        const np = state.songs.find((s) => songKey(s) === prevNowKey);
        state.nowPlayingId = np ? np.id : null;
      }

      rebuildFilterOptions();
      renderManual(data.manualGrid, data.manual);

      if (songs.length === 0) {
        songListEl.innerHTML = "";
        songEmptyMessage.style.display = "block";
        updateSheetStatus("ì™„ë£Œ (ê³¡ ì—†ìŒ)");
      } else {
        songEmptyMessage.style.display = "none";
        updateSheetStatus("ìµœì‹  ìƒíƒœ (" + songs.length + "ê³¡)");
      }

      // âœ… ì„œë²„ ì €ì¥ íë¥¼ ì ìš©í•´ì„œ ìƒˆë¡œê³ ì¹¨/ë‹¤ë¥¸ ê¸°ê¸°ì—ì„œë„ ìœ ì§€
      await loadQueueOnce();

      renderAll();
    } catch (err) {
      console.error(err);
      updateSheetStatus("ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨");
      songEmptyMessage.style.display = "block";
      songListEl.innerHTML = "";
      const manualList = document.getElementById("manualList");
      if (manualList) manualList.innerHTML = "<div class='empty'>ì„¤ëª…ì„œë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</div>";
    } finally {
      state.loading = false;
    }
  }

  // ===== ë Œë”ë§ =====
  function getFilteredSongs() {
    const q = normalizeText(state.search);
    const f = String(state.filter || "all");

    return state.songs.filter((song) => {
      if (f === "requested" && song.requestStatus !== "pending") return false;
      if (f === "unrequested" && song.requestStatus !== "none") return false;

      if (f.startsWith("cat:")) {
        const want = f.slice(4);
        if (want !== "__all__") {
          const have = String(song?.category ?? "").trim();
          if (have !== want) return false;
        }
      }

      if (!q) return true;

      const haystack =
        normalizeText(song.title) + " " +
        normalizeText(song.artistRaw) + " " +
        normalizeText(song.artistTags.join(" ")) + " " +
        normalizeText(song.category) + " " +
        normalizeText(song.tags.join(" ")) + " " +
        normalizeText(song.flagTags.join(" "));

      return haystack.includes(q);
    });
  }

  function renderSongs() {
    const container = document.getElementById("songList");
    const list = getFilteredSongs();
    container.innerHTML = "";

    if (!list.length) {
      container.innerHTML = "<div class='empty'>ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>";
      return;
    }

    list.forEach((song) => {
      const row = document.createElement("article");
      row.className = "song-row" + (song.requestStatus === "pending" ? " requested" : "");
      row.dataset.songId = song.id;

      const main = document.createElement("div");
      main.className = "song-main";

      const titleEl = document.createElement("div");
      titleEl.className = "song-title";
      // âœ… ë…¸ë˜ ëª©ë¡ ì˜†ì— ê°€ìˆ˜ í…ìŠ¤íŠ¸ëŠ” ì•ˆ ë‚˜ì˜¤ê²Œ(ì œëª©ë§Œ)
      titleEl.textContent = song.title;
      main.appendChild(titleEl);

      const meta = document.createElement("div");
      meta.className = "song-meta";

      // âœ… 1ë²ˆì§¸ íƒœê·¸: ì¹´í…Œê³ ë¦¬
      if (song.category) {
        const cat = document.createElement("span");
        cat.className = "tag";
        cat.textContent = song.category;
        meta.appendChild(cat);
      }

      // âœ… 2ë²ˆì§¸ë¶€í„°: ê°€ìˆ˜ íƒœê·¸(ì—¬ëŸ¬ëª…ì´ë©´ ì—¬ëŸ¬ íƒœê·¸)
      (song.artistTags || []).forEach((a) => {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = a;
        meta.appendChild(tag);
      });

      // ê¸°ì¡´ tags
      (song.tags || []).forEach((t) => {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = t;
        meta.appendChild(tag);
      });

      // âœ… ğŸ”ºğŸ‘¾ flagë„ íƒœê·¸ë¡œ í‘œì‹œ
      (song.flagTags || []).forEach((f) => {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = f;
        meta.appendChild(tag);
      });

      if (song.url) {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.style.background = "#fab1a0"; tag.style.color="#fff";
        tag.textContent = "â–¶";
        meta.appendChild(tag);
      }

      main.appendChild(meta);

      const actions = document.createElement("div");
      actions.className = "song-actions";

      const statusPill = document.createElement("span");
      statusPill.className = "song-status-pill";
      if (song.requestStatus === "pending") statusPill.textContent = "ì‹ ì²­ë¨";
      else if (song.requestStatus === "done") statusPill.textContent = "ì™„ë£Œ";
      else statusPill.textContent = "";

      if(!statusPill.textContent) statusPill.style.display="none";
      actions.appendChild(statusPill);

      const btn = document.createElement("button");
      btn.className = "song-btn";
      btn.textContent = song.requestStatus === "pending" ? "ì·¨ì†Œ" : "ì‹ ì²­";

      // âœ… ë¡œê·¸ì¸ í•„ìš”
      btn.addEventListener("click", () => {
        requireAuthThen(() => toggleRequest(song.id));
      });

      actions.appendChild(btn);

      row.appendChild(main);
      row.appendChild(actions);
      container.appendChild(row);
    });
  }

  function renderRequests() {
    const listEl = document.getElementById("requestList");
    const emptyMsg = document.getElementById("requestEmptyMessage");
    const tab = state.requestTab;

    const songs = state.songs
      .filter((s) => s.requestStatus === (tab === "pending" ? "pending" : "done"))
      .sort((a, b) => {
        const ao = a.requestOrder || 0;
        const bo = b.requestOrder || 0;
        if (ao === bo) return songKey(a) < songKey(b) ? -1 : 1;
        return ao - bo;
      });

    listEl.innerHTML = "";

    if (!songs.length) {
      emptyMsg.style.display = "block";
      return;
    } else {
      emptyMsg.style.display = "none";
    }

    songs.forEach((song) => {
      const row = document.createElement("article");
      row.className = "song-row requested";

      const main = document.createElement("div");
      main.className = "song-main";

      const title = document.createElement("div");
      title.className = "song-title";
      title.textContent = song.title;
      main.appendChild(title);

      const meta = document.createElement("div");
      meta.className = "song-meta";

      const src = document.createElement("span");
      src.textContent = "ì¶œì²˜: Manual";
      meta.appendChild(src);

      if (song.category) {
        const cat = document.createElement("span");
        cat.className = "tag";
        cat.textContent = song.category;
        meta.appendChild(cat);
      }

      (song.artistTags || []).forEach((a) => {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = a;
        meta.appendChild(tag);
      });

      (song.flagTags || []).forEach((f) => {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = f;
        meta.appendChild(tag);
      });

      main.appendChild(meta);

      const actions = document.createElement("div");
      actions.className = "song-actions";

      const status = document.createElement("span");
      status.className = "song-status-pill";
      status.textContent = tab === "pending" ? "Waiting" : "Done";
      actions.appendChild(status);

      if (tab === "pending") {
        const btnPlay = document.createElement("button");
        btnPlay.className = "song-btn";
        btnPlay.style.background = "var(--primary)";
        btnPlay.style.color = "#fff";
        btnPlay.textContent = "ì§€ê¸ˆ ë¶€ë¥´ê¸°";

        // âœ… ë¡œê·¸ì¸ í•„ìš”
        btnPlay.addEventListener("click", () => {
          requireAuthThen(() => setNowPlaying(song.id));
        });

        actions.appendChild(btnPlay);
      }

      row.appendChild(main);
      row.appendChild(actions);
      listEl.appendChild(row);
    });
  }

  function renderNowPlaying() {
    const card = document.getElementById("nowPlayingCard");
    const titleEl = document.getElementById("nowPlayingTitle");
    const metaEl = document.getElementById("nowPlayingMeta");
    const btnDone = document.getElementById("nowPlayingDoneBtn");

    const song =
      state.nowPlayingId != null
        ? state.songs.find((s) => s.id === state.nowPlayingId)
        : null;

    if (!song) {
      card.classList.add("empty");
      titleEl.textContent = "ì„ íƒëœ ê³¡ ì—†ìŒ";
      metaEl.textContent = "ëŒ€ê¸° ëª©ë¡ì—ì„œ 'ì§€ê¸ˆ ë¶€ë¥´ê¸°'ë¥¼ ì„ íƒí•˜ì„¸ìš”.";
      btnDone.disabled = true;
      return;
    }

    card.classList.remove("empty");
    titleEl.textContent = song.title;
    metaEl.textContent = "ğŸ¤ On Stage";
    btnDone.disabled = false;
  }

  function renderAll() {
    renderSongs();
    renderRequests();
    renderNowPlaying();
  }

  // ===== ìƒíƒœ ë³€ê²½ ë¡œì§ (âœ… ì„œë²„ ì €ì¥ íë¡œ ì „í™˜) =====
  async function toggleRequest(songId) {
    const song = state.songs.find((s) => s.id === songId);
    if (!song) return;
    try {
      await queueAction("toggle", songKey(song));
      renderAll();
    } catch (e) {
      alert("ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨: " + (e?.message || "error"));
    }
  }

  async function setNowPlaying(songId) {
    const song = state.songs.find((s) => s.id === songId);
    if (!song) return;
    try {
      await queueAction("nowPlaying", songKey(song));
      renderAll();
    } catch (e) {
      alert("ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨: " + (e?.message || "error"));
    }
  }

  async function markNowPlayingDone() {
    try {
      await queueAction("done", "");
      renderAll();
    } catch (e) {
      alert("ì™„ë£Œ ì²˜ë¦¬ ì‹¤íŒ¨: " + (e?.message || "error"));
    }
  }

  async function clearRequests() {
    try {
      await queueAction("clear", "");
      renderAll();
    } catch (e) {
      alert("ì´ˆê¸°í™” ì‹¤íŒ¨: " + (e?.message || "error"));
    }
  }

  // âœ… xì¶• íœ /ë“œë˜ê·¸ ë°©ì§€
  function initWheelBlocks_() {
    blockHorizontalWheel(document.getElementById("songList"));
    blockHorizontalWheel(document.getElementById("requestList"));
    blockHorizontalWheel(document.getElementById("manualList"));
  }

  // ===== DOM ì´ˆê¸°í™” =====
  window.addEventListener("DOMContentLoaded", async () => {
    const searchInput = document.getElementById("searchInput");
    const filterSelect = document.getElementById("filterSelect");
    const viewToggle = document.getElementById("viewToggle");
    const reloadBtn = document.getElementById("reloadBtn");
    const requestTabToggle = document.getElementById("requestTabToggle");
    const clearRequestsBtn = document.getElementById("clearRequestsBtn");
    const nowPlayingDoneBtn = document.getElementById("nowPlayingDoneBtn");

    const loginBtn = document.getElementById("loginBtn");
    const pwChangeBtn = document.getElementById("pwChangeBtn");
    const logoutBtn = document.getElementById("logoutBtn");

    const bd = document.getElementById("authModalBackdrop");
    const closeBtn = document.getElementById("authModalCloseBtn");
    const cancelBtn = document.getElementById("authCancelBtn");
    const okBtn = document.getElementById("authOkBtn");

    initWheelBlocks_();

    // âœ… ì´ˆê¸° auth í™•ì¸(ì¿ í‚¤ ìë™ ë¡œê·¸ì¸)
    await checkAuth();

    // âœ… í ë¨¼ì € í•œ ë²ˆ ë¡œë“œ(ê³¡ ì•„ì§ ì—†ìœ¼ë©´ ë‚˜ì¤‘ì— loadSheetì—ì„œ ë‹¤ì‹œ ì ìš©ë¨)
    await loadQueueOnce();

    // í—¤ë” ë²„íŠ¼
    if (loginBtn) {
      loginBtn.addEventListener("click", () => {
        state.pendingAction = null;
        openAuthModal("login");
      });
    }

    if (pwChangeBtn) {
      pwChangeBtn.addEventListener("click", () => {
        state.pendingAction = null;
        openAuthModal("change");
      });
    }

    if (logoutBtn) {
      logoutBtn.addEventListener("click", async () => {
        const ok = confirm("ë¡œê·¸ì•„ì›ƒí• ê¹Œìš”?");
        if (!ok) return;
        const done = await doLogout();
        if (!done) alert("ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨");
      });
    }

    // ëª¨ë‹¬ ë‹«ê¸°
    function onCloseModal() {
      closeAuthModal();
      state.pendingAction = null;
    }
    if (closeBtn) closeBtn.addEventListener("click", onCloseModal);
    if (cancelBtn) cancelBtn.addEventListener("click", onCloseModal);
    if (bd) {
      bd.addEventListener("click", (e) => {
        if (e.target === bd) onCloseModal();
      });
    }

    // ëª¨ë‹¬ í™•ì¸
    if (okBtn) {
      okBtn.addEventListener("click", async () => {
        const err = document.getElementById("authModalError");
        if (err) { err.style.display = "none"; err.textContent = ""; }

        if (state.authMode === "login") {
          const pw = document.getElementById("loginPassword")?.value || "";
          if (!pw.trim()) return showAuthError("ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì¤˜.");
          const r = await doLogin(pw);
          if (!r.ok) return showAuthError("ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•Šì•„.");
          closeAuthModal();

          const act = state.pendingAction;
          state.pendingAction = null;
          if (typeof act === "function") {
            try { await act(); } catch (e) { alert("ì‘ì—… ì‹¤íŒ¨: " + (e?.message || "error")); }
          }
          return;
        }

        // change password
        const cur = document.getElementById("currentPassword")?.value || "";
        const np1 = document.getElementById("newPassword")?.value || "";
        const np2 = document.getElementById("newPassword2")?.value || "";

        if (!cur.trim()) return showAuthError("í˜„ì¬ ë¹„ë°€ë²ˆí˜¸(ë˜ëŠ” ë§ˆìŠ¤í„°)ë¥¼ ì…ë ¥í•´ì¤˜.");
        if (!np1.trim() || np1.length < 4) return showAuthError("ìƒˆ ë¹„ë°€ë²ˆí˜¸ëŠ” 4ì ì´ìƒì´ì–´ì•¼ í•´.");
        if (np1 !== np2) return showAuthError("ìƒˆ ë¹„ë°€ë²ˆí˜¸ í™•ì¸ì´ ì¼ì¹˜í•˜ì§€ ì•Šì•„.");

        const r = await doChangePassword(cur, np1);
        if (!r.ok) {
          if (r.code === "reserved") return showAuthError("ì´ ë¹„ë°€ë²ˆí˜¸ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ì–´.");
          if (r.code === "invalid") return showAuthError("í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•Šì•„.");
          return showAuthError("ë³€ê²½ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì¤˜.");
        }

        alert("ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ëì–´.");
        closeAuthModal();
      });
    }

    // ì…ë ¥ ì´ë²¤íŠ¸
    searchInput.addEventListener("input", (e) => {
      state.search = e.target.value || "";
      renderSongs();
    });

    filterSelect.addEventListener("change", (e) => {
      state.filter = e.target.value;
      renderSongs();
    });

    viewToggle.querySelectorAll(".toggle").forEach((el) => {
      el.addEventListener("click", () => {
        viewToggle.querySelectorAll(".toggle").forEach((t) => t.classList.remove("active"));
        el.classList.add("active");
        const mode = el.dataset.mode || "list";
        state.viewMode = mode;
        if (mode === "compact") document.body.classList.add("compact-mode");
        else document.body.classList.remove("compact-mode");
      });
    });

    reloadBtn.addEventListener("click", () => {
      loadSheet(false);
    });

    requestTabToggle.querySelectorAll(".toggle").forEach((el) => {
      el.addEventListener("click", () => {
        requestTabToggle.querySelectorAll(".toggle").forEach((t) => t.classList.remove("active"));
        el.classList.add("active");
        state.requestTab = el.dataset.tab || "pending";
        renderRequests();
      });
    });

    // âœ… ì´ˆê¸°í™” ë²„íŠ¼: ë¡œê·¸ì¸ í•„ìš”
    clearRequestsBtn.addEventListener("click", () => {
      requireAuthThen(async () => {
        if (!confirm("ëª¨ë“  ì‹ ì²­ ê³¡ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
        await clearRequests();
      });
    });

    // âœ… ë…¸ë˜ ì™„ë£Œ ë²„íŠ¼: ë¡œê·¸ì¸ í•„ìš”
    nowPlayingDoneBtn.addEventListener("click", () => {
      requireAuthThen(async () => {
        await markNowPlayingDone();
      });
    });

    // ì´ˆê¸° ë¡œë“œ + ì£¼ê¸°ì  ê°±ì‹ 
    loadSheet(true);
    setInterval(() => loadSheet(false), 30000);

    // âœ… íëŠ” ë” ìì£¼ í´ë§(ë‹¤ë¥¸ ê¸°ê¸° ë³€ê²½ ë¹ ë¥´ê²Œ ë°˜ì˜)
    setInterval(() => loadQueueOnce(), 2500);
  });
</script>

</body>
</html>
