<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>ëª¨ë„¤ ì¸í„°ë™í‹°ë¸Œ ë…¸ë˜ì±… (Re-Design + Bubbles)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" />
<style>
:root{
  --primary:#9b72cf;
  --primary-2:#7e62c9;
  --primary-light:#e9ddff;

  /* âœ… â€œì£¼í™© ìµœëŒ€ = ì—°ë³´ë¼ì— ì‚´ì§ ì„ì¸ ì •ë„â€ */
  --accent:#f3a65b;          /* ê³¼í•œ ì£¼í™© X (ì±„ë„/ëª…ë„ ì¡°ì ˆ) */
  --accent-soft:#ffe9c9;

  --glass-bg:rgba(255,255,255,.62);
  --glass-border:rgba(255,255,255,.85);
  --glass-shadow:0 10px 34px 0 rgba(116,92,190,.14);

  --text-main:#1f2937;       /* ëŒ€ë¹„ â†‘ */
  --text-sub:#475569;        /* ëŒ€ë¹„ â†‘ */
  --text-soft:rgba(31,41,55,.62);

  --scale:1;
  --page-max:calc(1600px * var(--scale));

  --col-manual:clamp(380px, 26vw, 560px);
  --col-book:  clamp(520px, 40vw, 820px);
  --col-req:   clamp(380px, 28vw, 520px);
  --gap-layout:24px;

  --sheet-grid:rgba(185,185,185,.65);

  /* ìƒë‹¨ë°” ë†’ì´ ê¸°ì¤€(ëŒ€ëµ) */
  --topbar-pad:16px;
}

*{ box-sizing:border-box; }

body{
  margin:0;
  font-family:"Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
  color:var(--text-main);

  /* âœ… ê¸°ë³¸ ë°”íƒ•ìƒ‰(ì „í™˜ ì¤‘ì—ë„ ì „ì²´ í†¤ í†µì¼ê° ìœ ì§€) */
  background:#c792ff;

  min-height:100vh;
  overflow-x:hidden;
  position:relative;
  isolation:isolate;
}

/* âœ… â€œë³´ë¼ í†¤ ì „ìš© ë ˆì´ì–´â€ */
body::before{
  content:"";
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:-2;

  background:
    radial-gradient(circle at 12% 18%, rgba(255,255,255,.26) 0, transparent 58%),
    radial-gradient(circle at 88% 26%, rgba(255,255,255,.18) 0, transparent 60%),
    radial-gradient(circle at 42% 92%, rgba(255,255,255,.14) 0, transparent 62%),
    linear-gradient(135deg, #c792ff 0%, #ead9ff 55%, #b97cff 100%);

  background-size: 260% 260%;
  animation: gradientDrift 60s ease-in-out infinite;
}

/* âœ… â€œí¬ë¦¼ í†¤ ì „ìš© ë ˆì´ì–´â€ (opacityë¡œ ì²œì²œíˆ ë®ì—ˆë‹¤ê°€ ë‹¤ì‹œ ë¹ ì§) */
body::after{
  content:"";
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:-1;
  opacity:0;

  background:
    radial-gradient(circle at 12% 18%, rgba(255,255,255,.32) 0, transparent 58%),
    radial-gradient(circle at 88% 26%, rgba(255,255,255,.22) 0, transparent 60%),
    radial-gradient(circle at 42% 92%, rgba(255,255,255,.16) 0, transparent 62%),
    linear-gradient(135deg, #fff6dd 0%, #fff0cf 55%, #ffe6b9 100%);

  background-size: 260% 260%;
  animation: gradientDrift 60s ease-in-out infinite, gradientFade 10s ease-in-out infinite;
}

@keyframes gradientFade{
  0%{ opacity:0; }
  50%{ opacity:1; }
  100%{ opacity:0; }
}

@keyframes gradientDrift{
  0%{ background-position:0% 50%; }
  50%{ background-position:100% 50%; }
  100%{ background-position:0% 50%; }
}

/* ëª¨ì…˜ ìµœì†Œí™” ì„ í˜¸ */
@media (prefers-reduced-motion: reduce){
  body::before, body::after{ animation:none !important; }
  body::after{ opacity:1; }
}

/* ğŸ«§ ë¹„ëˆ—ë°©ìš¸ */
.bubbles{
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  pointer-events:none;
  z-index:0;
  overflow:hidden;
}
.bubble{
  position:absolute;
  bottom:-100px;
  border-radius:50%;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.85), rgba(255,255,255,.08));
  box-shadow: 0 0 12px rgba(255,255,255,.45);
  animation: rise 15s infinite ease-in;
  opacity:.55;
}
.bubble:nth-child(1){ width:40px; height:40px; left:10%; animation-duration:8s; }
.bubble:nth-child(2){ width:22px; height:22px; left:20%; animation-duration:6s; animation-delay:1s; }
.bubble:nth-child(3){ width:54px; height:54px; left:35%; animation-duration:10s; animation-delay:2s; }
.bubble:nth-child(4){ width:86px; height:86px; left:50%; animation-duration:12s; animation-delay:0s; }
.bubble:nth-child(5){ width:36px; height:36px; left:56%; animation-duration:7s; animation-delay:1s; }
.bubble:nth-child(6){ width:46px; height:46px; left:66%; animation-duration:9s; animation-delay:3s; }
.bubble:nth-child(7){ width:92px; height:92px; left:76%; animation-duration:14s; animation-delay:2s; }
.bubble:nth-child(8){ width:26px; height:26px; left:86%; animation-duration:6s; animation-delay:4s; }

@keyframes rise{
  0%{ transform:translateY(0) scale(1); opacity:0; }
  20%{ opacity:.78; }
  100%{ transform:translateY(-120vh) scale(1.2); opacity:0; }
}

::-webkit-scrollbar{ width:8px; height:8px; }
::-webkit-scrollbar-track{ background:rgba(255,255,255,.28); border-radius:4px; }
::-webkit-scrollbar-thumb{ background:rgba(155,114,207,.46); border-radius:4px; }
::-webkit-scrollbar-thumb:hover{ background:rgba(155,114,207,.75); }

main{
  position:relative;
  z-index:1;
  max-width:var(--page-max);
  margin:0 auto;
  padding:18px 20px 18px;
}

/* =========================
   âœ… ìƒë‹¨ ë°”(ì •ë ¬/ì˜¤ë²„í”Œë¡œìš° FIX v2)
   ========================= */
.topbar{
  margin-bottom: var(--gap-layout);
  display:grid;
  grid-template-columns: var(--col-manual) var(--col-book) var(--col-req);
  gap: var(--gap-layout);
  justify-content:center;
  align-items:stretch;
}
.topbar-surface{
  grid-column: 1 / -1;
  justify-self:stretch;
  width:100%;
  background: rgba(255,255,255,.58);
  backdrop-filter: blur(18px);
  -webkit-backdrop-filter: blur(18px);
  border: 1px solid var(--glass-border);
  border-radius: 26px;
  box-shadow: var(--glass-shadow);
  padding: var(--topbar-pad) 0;
  overflow:hidden;
}
.topbar-grid{
  display:grid;
  grid-template-columns: var(--col-manual) var(--col-book) var(--col-req);
  gap: var(--gap-layout);
  align-items:center;
  width:100%;
}
.topbar-left{
  grid-column: 1 / 3;
  min-width:0;
  padding-left:20px;
  padding-right:12px;
}
.topbar-right{
  grid-column: 3 / 4;
  min-width:0;
  width:100%;
  display:flex;
  justify-content:flex-end;
  padding-right:20px;
}

body.manual-hidden .topbar{
  grid-template-columns: 1.25fr 0.85fr;
  justify-content:stretch;
}
body.manual-hidden .topbar-grid{ grid-template-columns: 1.25fr 0.85fr; }
body.manual-hidden .topbar-left{ grid-column: 1 / 2; padding-left:20px; padding-right:12px; }
body.manual-hidden .topbar-right{ grid-column: 2 / 3; padding-right:20px; }

.title-row{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
  margin-bottom:6px;
}
.title-row h1{
  font-size:28px;
  font-weight:900;
  margin:0;
  background: linear-gradient(135deg, #6c5ce7, #a29bfe);
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
  text-shadow: 0 2px 12px rgba(162,155,254,.28);
  letter-spacing:-.6px;
}
.badge{
  font-size:11px;
  font-weight:800;
  padding:5px 10px;
  border-radius:999px;
  background:#fff;
  color:var(--primary-2);
  box-shadow:0 2px 10px rgba(0,0,0,.05);
  border:1px solid rgba(255,255,255,.7);
}
.subtitle{
  font-size:14px;
  color:var(--text-sub);
  line-height:1.35;
  font-weight:600;
}
.header-right{
  display:flex;
  align-items:center;
  justify-content:flex-end;
  gap:10px;
  flex-wrap:wrap;
  max-width:100%;
  min-width:0;
}
.status-pill{
  font-size:12px;
  font-weight:700;
  padding:8px 12px;
  border-radius:999px;
  background: rgba(255,255,255,.7);
  border:1px solid rgba(255,255,255,.95);
  backdrop-filter: blur(6px);
  display:flex;
  align-items:center;
  flex-wrap:wrap;
  max-width:100%;
  min-width:0;
  column-gap:8px;
  row-gap:6px;
  color:var(--text-sub);
  box-shadow:0 2px 10px rgba(0,0,0,.04);
}
.status-pill b{ color: var(--text-main); font-weight:900; }
.status-dot{
  width:9px; height:9px;
  border-radius:50%;
  background:#10b981;
  box-shadow:0 0 8px rgba(16,185,129,.65);
}
.mini-btn{
  border:none;
  border-radius:999px;
  padding:7px 12px;
  font-size:12px;
  font-weight:900;
  cursor:pointer;
  background: rgba(255,255,255,.92);
  color: var(--primary-2);
  border:1px solid rgba(155,114,207,.25);
  box-shadow:0 2px 10px rgba(0,0,0,.05);
  transition: transform .12s ease, box-shadow .18s ease;
  white-space:nowrap;
}
.mini-btn:hover{ transform: translateY(-1px); box-shadow:0 6px 16px rgba(0,0,0,.06); }
.mini-btn:active{ transform: translateY(0); }
.mini-btn.ghost{ background: rgba(255,255,255,.55); }
.mini-btn.accent{
  color:#8a4b10;
  border-color: rgba(243,166,91,.35);
  background: rgba(255,233,201,.7);
}

/* =========================
   âœ… ë ˆì´ì•„ì›ƒ
   ========================= */
.layout{
  display:grid;
  grid-template-columns: var(--col-manual) var(--col-book) var(--col-req);
  gap: var(--gap-layout);
  justify-content:center;
  align-items:stretch;
}
body.manual-hidden .layout{ grid-template-columns: 1.25fr 0.85fr; }
body.manual-hidden #manualCard{ display:none; }

/* =========================
   âœ… ë°˜ì‘í˜•
   ========================= */
@media (max-width: 1200px){
  .layout{ grid-template-columns: 1fr 1fr; }
  .layout > .card:nth-child(1){ grid-row: span 2; }
  .topbar{ display:block; }
  .topbar-surface{ width:100%; grid-column:auto; }
  .topbar-grid{ grid-template-columns: 1fr 1fr; }
  .topbar-right{
    justify-self:stretch;
    justify-content:flex-start;
    margin-top:10px;
  }
  .header-right{ justify-content:flex-start; }
  body.manual-hidden .topbar-grid{ grid-template-columns: 1fr 1fr; }
  .topbar-surface{ padding: var(--topbar-pad) 18px; }
  .topbar-left{ padding-left:0; padding-right:0; }
  .topbar-right{ padding-right:0; }
}
@media (max-width: 900px){
  .layout{ display:flex; flex-direction:column; gap: var(--gap-layout); }
  .topbar{ display:block; }
  .topbar-grid{ display:flex; flex-direction:column; gap:10px; align-items:stretch; }
  .topbar-right{ justify-content:flex-start; }
}

/* =========================
   âœ… ì¹´ë“œ
   ========================= */
.card{
  background: var(--glass-bg);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border:1px solid var(--glass-border);
  border-radius:24px;
  padding:20px;
  box-shadow: var(--glass-shadow);
  display:flex;
  flex-direction:column;
  transition: transform .2s ease;
  min-width:0;
  min-height: 520px;
}
@media (min-width: 901px){
  .layout > .card:first-child{
    position:sticky;
    top:18px;
    z-index:10;
    max-height: calc(100vh - 36px);
    overflow:hidden;
  }
}
.card-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:14px;
  padding-bottom:12px;
  border-bottom:1px solid rgba(0,0,0,.06);
}
.card-title{
  font-size:18px;
  font-weight:900;
  color: var(--text-main);
  display:flex;
  align-items:center;
  gap:8px;
}
.card-sub{
  font-size:13px;
  color: var(--text-sub);
  margin: -8px 0 14px 0;
  line-height:1.45;
  font-weight:600;
}

/* =========================
   âœ… ì»¨íŠ¸ë¡¤
   ========================= */
.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-bottom:14px;
  background: rgba(255,255,255,.45);
  padding:10px;
  border-radius:18px;
  border:1px solid rgba(255,255,255,.7);
}
.input,.select{
  padding:9px 16px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.9);
  background: rgba(255,255,255,.86);
  font-family:inherit;
  font-size:13px;
  outline:none;
  transition: all .18s;
  flex-grow:1;
  min-width:0;
  color: var(--text-main);
}
.input::placeholder{ color: rgba(71,85,105,.72); font-weight:600; }
.input:focus,.select:focus{
  background:#fff;
  box-shadow:0 0 0 3px rgba(155,114,207,.18);
  border-color: var(--primary);
}
.btn{
  border:none;
  border-radius:999px;
  padding:9px 16px;
  font-size:13px;
  font-weight:900;
  cursor:pointer;
  background: linear-gradient(135deg, var(--primary), #a29bfe);
  color:#fff;
  box-shadow:0 6px 16px rgba(108,92,231,.28);
  transition: transform .1s, box-shadow .2s;
}
.btn:hover{ transform: translateY(-2px); box-shadow:0 10px 24px rgba(108,92,231,.34); }
.btn:active{ transform: translateY(0); }
.toggle-group{
  display:inline-flex;
  background: rgba(255,255,255,.55);
  border-radius:999px;
  padding:3px;
  border:1px solid rgba(255,255,255,.75);
}
.toggle{
  padding:7px 14px;
  border-radius:999px;
  font-size:12px;
  font-weight:800;
  color: var(--text-sub);
  cursor:pointer;
  transition: all .18s;
}
.toggle.active{
  background:#fff;
  color: var(--primary-2);
  box-shadow:0 2px 8px rgba(0,0,0,.05);
}

/* âœ… ìŠ¤í¬ë¡¤ ì˜ì—­ */
.list{
  flex:1 1 auto;
  overflow-y:auto;
  overflow-x:hidden;
  padding:4px;
  scroll-behavior:smooth;
  min-height:0;
  touch-action: pan-y;
  overscroll-behavior: contain;
}

/* âœ… ë¦¬ìŠ¤íŠ¸ ë¹ˆ ìƒíƒœ */
.empty-state{
  height:100%;
  min-height: 220px;
  border-radius:18px;
  border:1px dashed rgba(0,0,0,.12);
  background: rgba(255,255,255,.42);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
  text-align:center;
  color: var(--text-sub);
}
.empty-state .icon{ font-size:28px; margin-bottom:8px; }
.empty-state .title{ font-weight:900; color: var(--text-main); margin-bottom:6px; }
.empty-state .desc{
  font-size:13px;
  line-height:1.45;
  font-weight:600;
  color: var(--text-sub);
  opacity:.95;
}

/* =========================
   âœ… ê³¡/ìš”ì²­ í–‰
   ========================= */
.song-row{
  position:relative;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:12px 16px;
  margin-bottom:8px;
  border-radius:16px;
  background: rgba(255,255,255,.74);
  border:1px solid rgba(255,255,255,.7);
  transition: all .18s ease;
  gap:12px;
  touch-action: pan-y;
}
.song-row:hover{
  background: rgba(255,255,255,.96);
  transform: scale(1.01) translateX(2px);
  box-shadow: 0 10px 20px rgba(0,0,0,.06);
}
.song-row.requested{
  background: linear-gradient(to right, rgba(255,245,230,.78), rgba(255,255,255,.9));
  border-left: 4px solid rgba(243,166,91,.95);
  box-shadow: 0 10px 24px rgba(243,166,91,.16);
}
.song-main{ flex:1; min-width:0; }
.song-title{
  font-size:15px;
  font-weight:900;
  color: var(--text-main);
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  margin-bottom:4px;
}
.song-meta{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  font-size:12px;
  color: var(--text-sub);
  font-weight:650;
}
.tag{
  background: rgba(108,92,231,.10);
  color: #5b4ad3;
  padding:2px 8px;
  border-radius:8px;
  font-size:11px;
  font-weight:800;
  border: 1px solid rgba(108,92,231,.18);
}
.tag.cat-all{ background:#EEF2FF; border-color:#C7D2FE; color:#334155; }
.tag.cat-musical{ background:#FFE4E6; border-color:#FB7185; color:#9F1239; }
.tag.cat-original{ background:#EDE9FE; border-color:#A78BFA; color:#5B21B6; }
.tag.cat-jpop{ background:#DBEAFE; border-color:#60A5FA; color:#1E40AF; }
.tag.cat-kpop{ background:#FAE8FF; border-color:#F0ABFC; color:#86198F; }
.tag.cat-ost{ background:#FFEDD5; border-color:#FDBA74; color:#9A3412; }
.tag.cat-pop{ background:#DCFCE7; border-color:#86EFAC; color:#166534; }

.select:hover{ background:#F3EDFF; }
.input:focus,.select:focus{
  background:#fff;
  border-color:#9B72CF;
  box-shadow:0 0 0 3px rgba(155,114,207,.22);
}
.select option:checked{ background:#9B72CF; color:#FFFFFF; }
.select option:hover{ background:#F3EDFF; }

.song-actions{
  display:flex;
  flex-direction:column;
  align-items:flex-end;
  gap:6px;
}
.song-btn{
  background: rgba(0,0,0,.03);
  border:1px solid rgba(0,0,0,.06);
  color: var(--text-sub);
  padding:6px 12px;
  border-radius:999px;
  font-size:12px;
  font-weight:900;
  cursor:pointer;
  transition: all .18s;
}
.song-btn:hover{
  background: var(--primary);
  color:#fff;
  border-color: var(--primary);
}
.song-status-pill{
  font-size:10px;
  font-weight:900;
  padding:3px 10px;
  border-radius:999px;
  background:#e2e8f0;
  color:#334155;
}
.requested .song-status-pill{
  background: rgba(255,233,201,.95);
  color:#8a4b10;
}
body.compact-mode .song-row{ padding:9px 12px; }
body.compact-mode .song-meta{ display:none; }

/* =========================
   âœ… Now Playing
   ========================= */
.now-playing{
  margin-bottom: 14px;
  padding: 18px;
  border-radius: 22px;
  background: linear-gradient(135deg, rgba(255,232,199,.95) 0%, rgba(247,216,232,.92) 100%);
  color: var(--text-main);
  box-shadow: 0 14px 30px rgba(243,166,91,.16);
  position:relative;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.75);
}
.now-playing::before{
  content:"â™«";
  position:absolute; right:-6px; bottom:-22px;
  font-size:110px;
  opacity:.18;
  color:#fff;
  transform: rotate(-18deg);
}
.now-playing.empty{
  background: rgba(255,255,255,.52);
  border: 2px dashed rgba(0,0,0,.12);
  box-shadow:none;
  opacity:1;
}
.now-playing-label{
  font-size:11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  font-weight: 900;
  opacity:.72;
  margin-bottom: 8px;
}
.now-playing-title{
  font-size:18px;
  font-weight: 950;
  margin-bottom:4px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  position:relative;
  z-index:1;
}
.now-playing-meta{
  font-size:13px;
  opacity:.9;
  margin-bottom:12px;
  position:relative;
  z-index:1;
  font-weight:650;
}
#nowPlayingDoneBtn{
  background:#fff;
  color:#8a4b10;
  border:none;
  padding:8px 14px;
  border-radius:999px;
  font-weight: 950;
  box-shadow: 0 8px 18px rgba(0,0,0,.10);
  position:relative;
  z-index:1;
  cursor:pointer;
}
#nowPlayingDoneBtn:disabled{
  opacity:.5;
  cursor:default;
  box-shadow:none;
}

/* =========================
   âœ… Footer
   ========================= */
footer{
  text-align:center;
  margin-top: 18px;
  font-size:12px;
  color: rgba(0,0,0,.40);
  padding-bottom: 6px;
}

/* =========================
   MANUAL (í‘œ ìŠ¤íƒ€ì¼)
   ========================= */
#manualList{
  flex: 1 1 auto;
  min-height:0;
  overflow-y:auto;
  overflow-x:hidden;
  padding: 10px 6px 12px;
  touch-action: pan-y;
  min-width:0;
}
.manual-sheet-wrap{
  border-radius: 16px;
  background: rgba(255,255,255,.94);
  border: 1px solid rgba(0,0,0,.08);
  box-shadow: 0 8px 18px rgba(0,0,0,.06);
  padding: 22px 18px;
  overflow:auto;
  -webkit-overflow-scrolling: touch;
}
table.manual-sheet{
  border-collapse: collapse;
  table-layout: fixed;
  background:#fff;
  width:max-content;
  min-width:0;
  margin:0 auto;
}
table.manual-sheet td{
  border: 1px solid var(--sheet-grid);
  padding: 6px 10px;
  font-size: 12px;
  line-height: 1.32;
  vertical-align: top;
  white-space: pre-wrap;
  word-break: break-word;
}
.manual-footer{
  margin-top: 12px;
  padding: 12px 12px;
  border-radius: 18px;
  background: rgba(255,255,255,.45);
  border: 1px solid rgba(255,255,255,.70);
}
.manual-footer .mf-title{
  font-weight: 950;
  color: var(--text-main);
  font-size: 12px;
  margin-bottom: 8px;
}
.manual-footer .mf-grid{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}
.manual-footer .mf-chip{
  font-size: 11px;
  font-weight: 900;
  padding: 6px 10px;
  border-radius: 999px;
  background: rgba(255,255,255,.86);
  border: 1px solid rgba(155,114,207,.22);
  color: var(--primary-2);
  box-shadow: 0 2px 10px rgba(0,0,0,.04);
}

/* =========================
   âœ… ë¡œê·¸ì¸ ëª¨ë‹¬
   ========================= */
.modal-backdrop{
  position:fixed;
  inset:0;
  background: rgba(0,0,0,.38);
  display:none;
  align-items:center;
  justify-content:center;
  padding:18px;
  z-index:9999;
}
.modal{
  width:min(420px, 100%);
  background: rgba(255,255,255,.94);
  backdrop-filter: blur(18px);
  border: 1px solid rgba(255,255,255,.92);
  border-radius: 18px;
  box-shadow: 0 18px 60px rgba(0,0,0,.20);
  overflow:hidden;
}
.modal-header{
  padding: 14px 16px;
  border-bottom: 1px solid rgba(0,0,0,.06);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.modal-title{
  font-size: 14px;
  font-weight: 950;
  color: var(--text-main);
}
.modal-body{ padding: 14px 16px; }
.modal-row{
  display:flex;
  flex-direction:column;
  gap:6px;
  margin-bottom:12px;
}
.modal-label{
  font-size: 12px;
  font-weight: 950;
  color: var(--text-sub);
}
.modal-input{
  width:100%;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(0,0,0,.12);
  outline:none;
  font-size: 13px;
  background: rgba(255,255,255,.97);
}
.modal-input:focus{
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(155,114,207,.18);
}
.modal-hint{
  font-size: 12px;
  color: rgba(0,0,0,.58);
  line-height:1.35;
  font-weight:600;
}
.modal-error{
  display:none;
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  background: rgba(255,118,117,.12);
  border: 1px solid rgba(255,118,117,.25);
  color: rgba(180,60,60,1);
  font-size: 12px;
  font-weight: 950;
}
.modal-footer{
  padding: 14px 16px;
  border-top: 1px solid rgba(0,0,0,.06);
  display:flex;
  gap:10px;
  justify-content:flex-end;
}
.modal-btn{
  border:none;
  border-radius: 12px;
  padding: 10px 14px;
  font-size: 12px;
  font-weight: 950;
  cursor:pointer;
}
.modal-btn.cancel{
  background: rgba(0,0,0,.06);
  color: rgba(0,0,0,.70);
}
.modal-btn.ok{
  background: linear-gradient(135deg, var(--primary), #a29bfe);
  color:#fff;
  box-shadow: 0 10px 26px rgba(108,92,231,.24);
}

/* =========================================================
   âœ… ëª¨ë°”ì¼: ì™¼ìª½ ì§¤ë¦¼ ë°©ì§€ + Manual ì ‘ê¸°
   ========================================================= */
@media (max-width: 900px){
  /* âœ… ëª¨ë°”ì¼ ì¹´ë“œ ê¸°ë³¸: PCì²˜ëŸ¼ ê³ ì • ë†’ì´ ê°•ì œí•˜ì§€ ë§ê³  ìì—°ìŠ¤ëŸ½ê²Œ */
  .card{ 
    min-height:auto; 
    height:auto; 
  }
  .layout{ justify-content:stretch; }

  /* âœ… [í•µì‹¬] ë…¸ë˜ ëª©ë¡ ì„¹í„°ë§Œ â€œì ë‹¹íˆâ€ ë†’ì´ ì œí•œ â†’ ë‚´ë¶€ ë¦¬ìŠ¤íŠ¸ë§Œ ìŠ¤í¬ë¡¤ */
  #songsCard{
    height: clamp(340px, 58vh, 600px);
  }
  /* ë¦¬ìŠ¤íŠ¸ê°€ ì¹´ë“œ ë†’ì´ë¥¼ ë¨¹ê³ , ì•ˆì—ì„œë§Œ ìŠ¤í¬ë¡¤ë˜ë„ë¡ */
  #songsCard #songList{
    flex: 1 1 auto;
    min-height: 0;
    overflow-y: auto; /* ì•ˆì „ì¥ì¹˜ (ê¸°ì¡´ .listì—ë„ ìˆì§€ë§Œ í™•ì‹¤íˆ) */
  }

  /* ===== ê¸°ì¡´ manual ê´€ë ¨ ===== */
  .manual-sheet-wrap{
    width:100%;
    max-width:100%;
    overflow:auto;
    padding: 18px 14px;
  }
  table.manual-sheet{
    width:max-content;
    min-width:0;
    margin:0 auto;
  }
  #manualToggleBadge{
    cursor:pointer;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  body.manual-collapsed #manualList{ display:none; }
  body.manual-collapsed #manualCard{ padding-bottom: 12px; }
}
</style>
</head>
<body>

<div class="bubbles">
  <div class="bubble"></div><div class="bubble"></div><div class="bubble"></div><div class="bubble"></div>
  <div class="bubble"></div><div class="bubble"></div><div class="bubble"></div><div class="bubble"></div>
</div>

<main>
<header class="topbar">
  <div class="topbar-surface">
    <div class="topbar-grid">
      <div class="topbar-left">
        <div class="title-row">
          <h1>âœ¨ ëª¨ë„¤ ë…¸ë˜ì±… ë·°ì–´</h1>
          <span class="badge">Live Sync</span>
          <button class="mini-btn ghost" id="guideToggleBtn" type="button" aria-pressed="false">ğŸ“˜ ê°€ì´ë“œ ìˆ¨ê¹€</button>
        </div>
        <div class="subtitle">ì¦ê±°ìš´ ë°©ì†¡ì„ ìœ„í•œ ì‹ ì²­ê³¡ ê´€ë¦¬ ë§¤ë‹ˆì € ğŸµ</div>
      </div>

      <div class="topbar-right">
        <div class="header-right">
          <div class="status-pill" title="ì¸ì¦ ìƒíƒœ">
            <span class="status-dot"></span>
            <span>System: <b id="authStatusText">Locked</b></span>
          </div>

          <div class="status-pill" title="ì‹œíŠ¸ ë™ê¸°í™” ìƒíƒœ">
            <span>Data: <b id="sheetStatus">ë¡œë”© ì¤‘...</b></span>
            <button class="mini-btn" id="loginBtn" type="button">ë¡œê·¸ì¸</button>
            <button class="mini-btn accent" id="pwChangeBtn" type="button" style="display:none;">ë¹„ë²ˆ ë³€ê²½</button>
            <button class="mini-btn" id="logoutBtn" type="button" style="display:none;">ë¡œê·¸ì•„ì›ƒ</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</header>

<section class="layout">

  <section class="card" id="manualCard">
    <div class="card-header">
      <div class="card-title">ğŸ“˜ ì´ìš© ê°€ì´ë“œ</div>
      <div class="badge" id="manualToggleBadge" role="button" tabindex="0" aria-controls="manualList" aria-expanded="true">Manual</div>
    </div>

    <div id="manualList">
      <div class="empty-state">
        <div>
          <div class="icon">ğŸ“˜</div>
          <div class="title">ì„¤ëª…ì„œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</div>
          <div class="desc">ì‹œíŠ¸ì˜ Manual ì˜ì—­ì„ ë™ê¸°í™”í•˜ê³  ìˆì–´ìš”.</div>
        </div>
      </div>
    </div>

    <div class="manual-footer" aria-label="ë¹ ë¥¸ ë„ì›€ë§">
      <div class="mf-title">ë¹ ë¥¸ ë„ì›€ë§</div>
      <div class="mf-grid">
        <div class="mf-chip">Ctrl+Fë¡œ ë¹ ë¥¸ ê²€ìƒ‰</div>
        <div class="mf-chip">ê°€ì´ë“œ ìˆ¨ê¹€ìœ¼ë¡œ 2ì—´ í™•ì¥</div>
        <div class="mf-chip">ëª¨ë°”ì¼: Manual ë°°ì§€ë¡œ ì ‘ê¸°</div>
      </div>
    </div>
  </section>

  <section class="card" id="songsCard">
    <div class="card-header">
      <div class="card-title">ğŸµ ë…¸ë˜ ëª©ë¡</div>
      <div class="badge" style="background:var(--primary-light); color:var(--primary-2)">Auto Load</div>
    </div>
    <p class="card-sub">Google Sheetì—ì„œ ë°ì´í„°ë¥¼ ìë™ìœ¼ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤. (30ì´ˆ ì£¼ê¸° ê°±ì‹ )</p>

    <div class="controls">
      <input class="input" type="text" placeholder="ğŸ” ê³¡ëª…, ê°€ìˆ˜, íƒœê·¸ ê²€ìƒ‰..." id="searchInput" />

      <select class="select" id="filterSelect" style="max-width:180px;">
        <optgroup label="ìƒíƒœ">
          <option value="all" selected>ì „ì²´ ë³´ê¸°</option>
          <option value="unrequested">ë¯¸ì‹ ì²­ ê³¡</option>
          <option value="requested">ì‹ ì²­ëœ ê³¡</option>
        </optgroup>
        <optgroup label="ì¹´í…Œê³ ë¦¬" id="categoryOptGroup">
          <option value="cat:__all__">ì¹´í…Œê³ ë¦¬: ì „ì²´</option>
        </optgroup>
      </select>

      <div class="toggle-group" id="viewToggle">
        <div class="toggle active" data-mode="list">ê¸°ë³¸</div>
        <div class="toggle" data-mode="compact">ì‘ê²Œ</div>
      </div>

      <button class="btn" id="reloadBtn">â†» ìƒˆë¡œê³ ì¹¨</button>
    </div>

    <div class="list" id="songList"></div>
    <div class="empty-state" id="songEmptyMessage" style="display:none;">
      <div>
        <div class="icon">âš ï¸</div>
        <div class="title">ë…¸ë˜ì±… ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆì–´ìš”</div>
        <div class="desc">ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.</div>
      </div>
    </div>
  </section>

  <section class="card" id="requestsCard">
    <div class="card-header">
      <div class="card-title">ğŸ’Œ ì‹ ì²­ê³¡ ë¦¬ìŠ¤íŠ¸</div>
      <div class="badge" style="background:var(--accent-soft); color:#8a4b10">Request</div>
    </div>

    <div class="now-playing empty" id="nowPlayingCard">
      <div class="now-playing-label">Now Playing</div>
      <div class="now-playing-title" id="nowPlayingTitle">ì„ íƒëœ ê³¡ ì—†ìŒ</div>
      <div class="now-playing-meta" id="nowPlayingMeta">ëŒ€ê¸° ëª©ë¡ì—ì„œ 'ì§€ê¸ˆ ë¶€ë¥´ê¸°'ë¥¼ ì„ íƒí•˜ì„¸ìš”.</div>
      <button id="nowPlayingDoneBtn" disabled>ë…¸ë˜ ì™„ë£Œ</button>
    </div>

    <div class="controls" style="justify-content: space-between;">
      <div class="toggle-group" id="requestTabToggle">
        <div class="toggle active" data-tab="pending">ëŒ€ê¸° ì¤‘</div>
        <div class="toggle" data-tab="done">ì™„ë£Œë¨</div>
      </div>
      <button class="btn" id="clearRequestsBtn" style="background:#ff7675; box-shadow:0 6px 16px rgba(255,118,117,.25)">ì´ˆê¸°í™”</button>
    </div>

    <div class="list" id="requestList"></div>
  </section>

</section>

<footer>MONE Interactive Songbook Viewer &copy; 2024</footer>
</main>

<div class="modal-backdrop" id="authModalBackdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="authModalTitle">
    <div class="modal-header">
      <div class="modal-title" id="authModalTitle">ê´€ë¦¬ì ì¸ì¦</div>
      <button class="mini-btn" id="authModalCloseBtn" type="button">ë‹«ê¸°</button>
    </div>

    <div class="modal-body">
      <div class="modal-hint" id="authModalHint">
        ë²„íŠ¼(ì‹ ì²­/ì·¨ì†Œ/ì§€ê¸ˆë¶€ë¥´ê¸°/ì´ˆê¸°í™”/ë…¸ë˜ì™„ë£Œ)ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë¹„ë°€ë²ˆí˜¸ê°€ í•„ìš”í•©ë‹ˆë‹¤.
      </div>

      <div id="loginForm">
        <div class="modal-row">
          <div class="modal-label">ë¹„ë°€ë²ˆí˜¸</div>
          <input class="modal-input" id="loginPassword" type="password" autocomplete="current-password" placeholder="ë¹„ë°€ë²ˆí˜¸ ì…ë ¥" />
        </div>
      </div>

      <div id="changePwForm" style="display:none;">
        <div class="modal-row">
          <div class="modal-label">í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ (ë˜ëŠ” ë§ˆìŠ¤í„°)</div>
          <input class="modal-input" id="currentPassword" type="password" autocomplete="current-password" placeholder="í˜„ì¬ ë¹„ë°€ë²ˆí˜¸" />
        </div>
        <div class="modal-row">
          <div class="modal-label">ìƒˆ ë¹„ë°€ë²ˆí˜¸</div>
          <input class="modal-input" id="newPassword" type="password" autocomplete="new-password" placeholder="ìƒˆ ë¹„ë°€ë²ˆí˜¸ (4~64ì)" />
        </div>
        <div class="modal-row">
          <div class="modal-label">ìƒˆ ë¹„ë°€ë²ˆí˜¸ í™•ì¸</div>
          <input class="modal-input" id="newPassword2" type="password" autocomplete="new-password" placeholder="í•œ ë²ˆ ë” ì…ë ¥" />
        </div>
      </div>

      <div class="modal-error" id="authModalError">ì—ëŸ¬</div>
    </div>

    <div class="modal-footer">
      <button class="modal-btn cancel" id="authCancelBtn" type="button">ì·¨ì†Œ</button>
      <button class="modal-btn ok" id="authOkBtn" type="button">í™•ì¸</button>
    </div>
  </div>
</div>

<script>
  const state = {
    songs: [],
    songByKey: new Map(),

    filter: "all",
    search: "",
    viewMode: "list",
    requestTab: "pending",
    nowPlayingId: null,
    nextRequestOrder: 1,
    loading: false,

    authenticated: false,
    authMode: "login",
    pendingAction: null,

    manualHiddenDesktop: false,

    // âœ… queue polling/patch ìµœì í™”
    queueEtag: "",
    lastQueueUpdatedAt: null,
    lastQueue: null,

    // âœ… songbook ETag
    songbookEtag: "",
    lastSongbookHash: "",

    // âœ… ë Œë” í† í° (chunk ë Œë” ì·¨ì†Œìš©)
    songRenderToken: 0,
  };

  const domCache = {
    // key -> { row, statusEl, btnEl }
    songRowByKey: new Map(),
  };

  function normalizeText(str) {
    if (!str) return "";
    return String(str).toLowerCase().trim();
  }

  function normalizeCatKey(cat) {
    const s = String(cat ?? "").trim();
    if (!s) return "";
    const up = s.toUpperCase().replace(/\s+/g, "");
    if (up.includes("JPOP")) return "jpop";
    if (up.includes("KPOP")) return "kpop";
    if (up.includes("OST"))  return "ost";
    if (up === "POP" || up.includes("POP")) return "pop";
    if (s.includes("ì „ì²´")) return "all";
    if (s.includes("ë®¤ì§€ì»¬")) return "musical";
    if (s.includes("ì˜¤ë¦¬ì§€ë„")) return "original";
    return "";
  }

  function applyCategoryClassToTag(el, textValue) {
    const k = normalizeCatKey(textValue);
    if (k) el.classList.add("cat-" + k);
  }

  function songKey(song) {
    return normalizeText(song.title) + "|" + normalizeText(song.artistRaw);
  }

  function getCookie(name) {
    const m = document.cookie.match(new RegExp("(^|; )" + name.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "=([^;]*)"));
    return m ? decodeURIComponent(m[2]) : "";
  }

  function authHeaders(extra = {}) {
    const csrf = getCookie("mone_csrf");
    const h = { ...extra };
    if (csrf) h["X-CSRF-Token"] = csrf;
    return h;
  }

  async function authFetch(url, opts = {}) {
    const o = { ...opts };
    o.credentials = "include";
    o.headers = { ...(opts.headers || {}) };
    return fetch(url, o);
  }

  function setAuthUI(isAuthed) {
    state.authenticated = !!isAuthed;
    const t = document.getElementById("authStatusText");
    const loginBtn = document.getElementById("loginBtn");
    const pwBtn = document.getElementById("pwChangeBtn");
    const logoutBtn = document.getElementById("logoutBtn");

    if (t) t.textContent = isAuthed ? "Ready" : "Locked";
    if (loginBtn) loginBtn.style.display = isAuthed ? "none" : "inline-flex";
    if (pwBtn) pwBtn.style.display = isAuthed ? "inline-flex" : "none";
    if (logoutBtn) logoutBtn.style.display = isAuthed ? "inline-flex" : "none";

    // âœ… ì¸ì¦ ìƒíƒœê°€ ë°”ë€Œë©´ í´ë§ í…œí¬ë„ ë°”ë€Œë‹ˆ ì¦‰ì‹œ ì¬ì‹œì‘
    try { startQueuePolling_({ immediate: true }); } catch(_) {}
  }

  async function checkAuth() {
    try {
      const r = await authFetch("/api/auth/me", { method: "GET" });
      const j = await r.json().catch(() => null);
      setAuthUI(!!j?.authenticated);
      return !!j?.authenticated;
    } catch (_) {
      setAuthUI(false);
      return false;
    }
  }

  function openAuthModal(mode) {
    state.authMode = mode || "login";
    const bd = document.getElementById("authModalBackdrop");
    const title = document.getElementById("authModalTitle");
    const hint = document.getElementById("authModalHint");
    const err = document.getElementById("authModalError");
    const loginForm = document.getElementById("loginForm");
    const changeForm = document.getElementById("changePwForm");

    if (err) { err.style.display = "none"; err.textContent = ""; }

    if (state.authMode === "login") {
      if (title) title.textContent = "ê´€ë¦¬ì ì¸ì¦";
      if (hint) hint.textContent = "ë²„íŠ¼(ì‹ ì²­/ì·¨ì†Œ/ì§€ê¸ˆë¶€ë¥´ê¸°/ì´ˆê¸°í™”/ë…¸ë˜ì™„ë£Œ)ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë¹„ë°€ë²ˆí˜¸ê°€ í•„ìš”í•©ë‹ˆë‹¤.";
      if (loginForm) loginForm.style.display = "block";
      if (changeForm) changeForm.style.display = "none";
      const inp = document.getElementById("loginPassword");
      if (inp) { inp.value = ""; setTimeout(() => inp.focus(), 10); }
    } else {
      if (title) title.textContent = "ë¹„ë°€ë²ˆí˜¸ ë³€ê²½";
      if (hint) hint.textContent = "í˜„ì¬ ë¹„ë°€ë²ˆí˜¸(ë˜ëŠ” ë§ˆìŠ¤í„°)ë¡œ í™•ì¸ í›„ ìƒˆ ë¹„ë°€ë²ˆí˜¸ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.";
      if (loginForm) loginForm.style.display = "none";
      if (changeForm) changeForm.style.display = "block";
      const a = document.getElementById("currentPassword");
      const b = document.getElementById("newPassword");
      const c = document.getElementById("newPassword2");
      if (a) a.value = "";
      if (b) b.value = "";
      if (c) c.value = "";
      if (a) setTimeout(() => a.focus(), 10);
    }

    if (bd) bd.style.display = "flex";
    if (bd) bd.setAttribute("aria-hidden", "false");
  }

  function closeAuthModal() {
    const bd = document.getElementById("authModalBackdrop");
    if (bd) bd.style.display = "none";
    if (bd) bd.setAttribute("aria-hidden", "true");
  }

  function showAuthError(msg) {
    const err = document.getElementById("authModalError");
    if (!err) return;
    err.textContent = msg || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
    err.style.display = "block";
  }

  async function doLogin(password) {
    try {
      const r = await authFetch("/api/auth/login", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ password }),
      });
      const j = await r.json().catch(() => null);
      if (!r.ok || !j?.authenticated) return { ok: false };
      setAuthUI(true);
      return { ok: true };
    } catch (_) {
      return { ok: false };
    }
  }

  async function doLogout() {
    try {
      const r = await authFetch("/api/auth/logout", {
        method: "POST",
        headers: authHeaders({ "content-type": "application/json" }),
        body: JSON.stringify({}),
      });
      const j = await r.json().catch(() => null);
      if (!r.ok || !j?.ok) return false;
      setAuthUI(false);
      return true;
    } catch (_) {
      return false;
    }
  }

  async function doChangePassword(currentPassword, newPassword) {
    try {
      const r = await authFetch("/api/auth/change-password", {
        method: "POST",
        headers: authHeaders({ "content-type": "application/json" }),
        body: JSON.stringify({ currentPassword, newPassword }),
      });
      const j = await r.json().catch(() => null);
      if (!r.ok || !j?.ok) return { ok: false, code: j?.error || "fail" };
      return { ok: true };
    } catch (_) {
      return { ok: false, code: "network" };
    }
  }

  async function requireAuthThen(actionFn) {
    const ok = await checkAuth();
    if (ok) return Promise.resolve(actionFn());
    state.pendingAction = actionFn;
    openAuthModal("login");
  }

  function blockHorizontalWheel(el) {
    if (!el) return;
    el.addEventListener("wheel", (e) => {
      if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) e.preventDefault();
    }, { passive: false });
  }

  const API_URL = "/api/songbook";
  const QUEUE_URL = "/api/queue";

  function coalesce(obj, keys) {
    for (const k of keys) {
      const v = obj?.[k];
      if (v != null && String(v).trim() !== "") return String(v);
    }
    return "";
  }

  function normalizeTags(v) {
    if (Array.isArray(v)) return v.map(x => String(x).trim()).filter(Boolean);
    if (!v) return [];
    return String(v).split(/[;,]/).map(x => x.trim()).filter(Boolean);
  }

  function splitArtists(artistRaw) {
    const s = String(artistRaw ?? "").trim();
    if (!s) return [];
    return s.split(",").map(x => x.trim()).filter(Boolean);
  }

  function apiSongToSong(item, idx) {
    const title = coalesce(item, ["title","ê³¡ëª…","ì œëª©","song","Song","Title"]);
    const artistRaw = coalesce(item, ["artist","ê°€ìˆ˜","ì•„í‹°ìŠ¤íŠ¸","singer","Artist"]);
    const lang = coalesce(item, ["lang","language","ì–¸ì–´","Lang"]);
    const url = coalesce(item, ["url","link","youtube","ìœ íŠœë¸Œ","ë§í¬","URL"]);
    const category = coalesce(item, ["category","ì¹´í…Œê³ ë¦¬","ë¶„ë¥˜","Category"]);
    const flag = coalesce(item, ["flag","Flag","í‘œì‹œ","mark","Mark"]);
    const tags = normalizeTags(item?.tags ?? item?.tag ?? item?.genre ?? item?.ì¥ë¥´ ?? item?.ë¶„ë¥˜);

    const artistTags = splitArtists(artistRaw);
    const flagTags = flag ? [flag] : [];
    const raw = (item?.raw && typeof item.raw === "object") ? item.raw : { ...item };

    return {
      id: idx,
      title,
      artistRaw,
      artistTags,
      lang,
      url,
      category,
      tags,
      flagTags,
      requestStatus: "none",
      requestOrder: null,
      raw,
    };
  }

  function updateSheetStatus(text) {
    const el = document.getElementById("sheetStatus");
    if (el) el.textContent = text;
  }

  // =========================
  // âœ… Queue diff + patch (í•µì‹¬)
  // =========================
  function normalizeQueue_(q) {
    if (!q || typeof q !== "object") return { v: 1, updatedAt: null, nextOrder: 1, nowPlayingKey: null, items: {} };
    return {
      v: 1,
      updatedAt: q.updatedAt ?? null,
      nextOrder: Number(q.nextOrder ?? 1) || 1,
      nowPlayingKey: q.nowPlayingKey ?? null,
      items: (q.items && typeof q.items === "object") ? q.items : {},
    };
  }

  function diffQueue_(prevQ, nextQ) {
    const prev = normalizeQueue_(prevQ);
    const next = normalizeQueue_(nextQ);

    const changed = new Set();
    const a = prev.items;
    const b = next.items;

    for (const k in a) {
      const ai = a[k];
      const bi = b[k];
      if (!bi) { changed.add(k); continue; }
      const as = String(ai?.status ?? "pending");
      const bs = String(bi?.status ?? "pending");
      const ao = Number(ai?.order ?? 0) || 0;
      const bo = Number(bi?.order ?? 0) || 0;
      if (as !== bs || ao !== bo) changed.add(k);
    }
    for (const k in b) {
      if (!a[k]) changed.add(k);
    }

    const nowChanged = String(prev.nowPlayingKey ?? "") !== String(next.nowPlayingKey ?? "");
    const nextOrderChanged = Number(prev.nextOrder ?? 0) !== Number(next.nextOrder ?? 0);

    return { changedKeys: Array.from(changed), nowChanged, nextOrderChanged };
  }

  function applyQueuePatch_(nextQueue, diff) {
    const q = normalizeQueue_(nextQueue);
    const items = q.items;

    let membershipChange = false;
    const f = String(state.filter || "all");
    const sensitive = (f === "requested" || f === "unrequested");

    for (const key of diff.changedKeys) {
      const song = state.songByKey.get(key);
      if (!song) continue;

      const old = song.requestStatus;
      const it = items[key];

      if (!it) {
        song.requestStatus = "none";
        song.requestOrder = null;
      } else {
        song.requestStatus = (String(it.status) === "done") ? "done" : "pending";
        song.requestOrder = Number(it.order ?? null);
      }

      if (sensitive) {
        const inOld = (f === "requested") ? (old === "pending") : (old === "none");
        const inNew = (f === "requested") ? (song.requestStatus === "pending") : (song.requestStatus === "none");
        if (inOld !== inNew) membershipChange = true;
      }
    }

    state.nextRequestOrder = Number(q.nextOrder ?? state.nextRequestOrder ?? 1) || 1;

    if (diff.nowChanged) {
      const nowKey = String(q.nowPlayingKey ?? "") || null;
      const np = nowKey ? state.songByKey.get(nowKey) : null;
      state.nowPlayingId = np ? np.id : null;
    }

    return { membershipChange };
  }

  function updateSongRowUI_(song, entry) {
    if (!song || !entry) return;
    const isPending = song.requestStatus === "pending";
    const isDone = song.requestStatus === "done";

    entry.row.classList.toggle("requested", isPending);

    if (entry.statusEl) {
      if (isPending) entry.statusEl.textContent = "ì‹ ì²­ë¨";
      else if (isDone) entry.statusEl.textContent = "ì™„ë£Œ";
      else entry.statusEl.textContent = "";

      entry.statusEl.style.display = entry.statusEl.textContent ? "" : "none";
    }
    if (entry.btnEl) {
      entry.btnEl.textContent = isPending ? "ì·¨ì†Œ" : "ì‹ ì²­";
    }
  }

  function updateSongRowsByKeys_(keys) {
    for (const k of keys) {
      const entry = domCache.songRowByKey.get(k);
      if (!entry) continue;
      const song = state.songByKey.get(k);
      if (!song) continue;
      updateSongRowUI_(song, entry);
    }
  }

  // =========================
  // âœ… Queue load (ETag + updatedAt + patch + ìµœì†Œ DOM ì—…ë°ì´íŠ¸)
  // =========================
  async function loadQueueOnce(opts = {}) {
    const force = !!opts.force;

    try {
      const headers = {};
      if (!force && state.queueEtag) headers["If-None-Match"] = state.queueEtag;

      const r = await fetch(QUEUE_URL, { cache: "no-store", headers });
      if (r.status === 304) return;

      const etag = r.headers.get("etag");
      if (etag) state.queueEtag = etag;

      const j = await r.json().catch(() => null);
      if (!r.ok || !j?.ok) return;

      const nextQueue = normalizeQueue_(j.queue);
      const updatedAt = nextQueue.updatedAt ?? null;

      if (!force && updatedAt && state.lastQueueUpdatedAt === updatedAt) return;

      const diff = diffQueue_(state.lastQueue, nextQueue);

      state.lastQueue = nextQueue;
      state.lastQueueUpdatedAt = updatedAt;

      const { membershipChange } = applyQueuePatch_(nextQueue, diff);

      if (membershipChange) {
        renderSongsFull_(); // êµ¬ì„± ë³€ë™ â†’ chunk ì „ì²´ ë Œë”
      } else {
        updateSongRowsByKeys_(diff.changedKeys); // âœ… í•µì‹¬: ë³€ê²½ëœ rowë§Œ ì—…ë°ì´íŠ¸
      }

      // ìš”ì²­/NowPlayingì€ queue.itemsë§Œ ìˆœíšŒ (ì „ì²´ songs ìŠ¤ìº” X)
      renderRequests();
      renderNowPlaying();
      scheduleCardSync_();
    } catch (_) {}
  }

  async function queueAction(type, key = "") {
    const r = await authFetch("/api/queue/action", {
      method: "POST",
      headers: authHeaders({ "content-type": "application/json" }),
      body: JSON.stringify({ type, key }),
    });
    const j = await r.json().catch(() => null);
    if (!r.ok || !j?.ok) throw new Error(j?.error || "fail");

    // âœ… ì„œë²„ ì‘ë‹µ queueë¡œ ì¦‰ì‹œ patch(í´ë§ ê¸°ë‹¤ë¦¬ì§€ ì•ŠìŒ)
    const nextQueue = normalizeQueue_(j.queue);
    const diff = diffQueue_(state.lastQueue, nextQueue);
    state.lastQueue = nextQueue;
    state.lastQueueUpdatedAt = nextQueue.updatedAt ?? null;

    const { membershipChange } = applyQueuePatch_(nextQueue, diff);
    if (membershipChange) renderSongsFull_();
    else updateSongRowsByKeys_(diff.changedKeys);

    renderRequests();
    renderNowPlaying();
    scheduleCardSync_();
  }

  function rebuildFilterOptions() {
    const select = document.getElementById("filterSelect");
    if (!select) return;

    const prev = String(select.value || "all");
    const set = new Set();
    state.songs.forEach((s) => {
      const c = String(s?.category ?? "").trim();
      if (c) set.add(c);
    });
    const categories = Array.from(set).sort((a, b) => a.localeCompare(b, "ko"));
    select.innerHTML = "";

    const ogState = document.createElement("optgroup");
    ogState.label = "ìƒíƒœ";

    const optAll = document.createElement("option");
    optAll.value = "all";
    optAll.textContent = "ì „ì²´ ë³´ê¸°";
    ogState.appendChild(optAll);

    const optUn = document.createElement("option");
    optUn.value = "unrequested";
    optUn.textContent = "ë¯¸ì‹ ì²­ ê³¡";
    ogState.appendChild(optUn);

    const optReq = document.createElement("option");
    optReq.value = "requested";
    optReq.textContent = "ì‹ ì²­ëœ ê³¡";
    ogState.appendChild(optReq);

    select.appendChild(ogState);

    const ogCat = document.createElement("optgroup");
    ogCat.label = "ì¹´í…Œê³ ë¦¬";

    const optCatAll = document.createElement("option");
    optCatAll.value = "cat:__all__";
    optCatAll.textContent = "ì¹´í…Œê³ ë¦¬: ì „ì²´";
    ogCat.appendChild(optCatAll);

    categories.forEach((c) => {
      const opt = document.createElement("option");
      opt.value = "cat:" + c;
      opt.textContent = c;
      ogCat.appendChild(opt);
    });

    select.appendChild(ogCat);

    const exists = Array.from(select.options).some(o => o.value === prev);
    select.value = exists ? prev : "all";
    state.filter = select.value;
  }

  /* =========================
     âœ… Manual (í‘œ ë Œë”)
     ========================= */
  const MANUAL_ZOOM_DESKTOP = 1.06;
  const MANUAL_ZOOM_MOBILE  = 1.00;

  const _manualCache = { grid: null, flat: null };
  let _manualRenderToken = 0;
  let _manualFontsHooked = false;

  function cacheManual_(grid, flat) {
    _manualCache.grid = grid || null;
    _manualCache.flat = Array.isArray(flat) ? flat : (flat || null);
  }

  function isMobile_() {
    return window.matchMedia && window.matchMedia("(max-width: 900px)").matches;
  }

  function isManualVisibleForRender_() {
    if (isMobile_()) {
      return !document.body.classList.contains("manual-collapsed");
    }
    return !document.body.classList.contains("manual-hidden");
  }

  function hookFontsReadyOnce_() {
    if (_manualFontsHooked) return;
    _manualFontsHooked = true;
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => {
        if (isManualVisibleForRender_()) scheduleManualRender_("fonts");
      }).catch(() => {});
    }
  }

  function scheduleManualRender_(reason = "unknown") {
    const token = ++_manualRenderToken;
    const list = document.getElementById("manualList");
    if (!list) return;
    if (!isManualVisibleForRender_()) return;

    const MIN_W = isMobile_() ? 120 : 220;
    const MAX_TRIES = 24;

    const step = (tries) => {
      if (token !== _manualRenderToken) return;
      if (!isManualVisibleForRender_()) return;

      const el = document.getElementById("manualList");
      if (!el) return;

      const w = Math.ceil(el.getBoundingClientRect().width || 0);
      if (w < MIN_W && tries < MAX_TRIES) {
        requestAnimationFrame(() => step(tries + 1));
        return;
      }
      if (w < MIN_W) {
        setTimeout(() => {
          if (token === _manualRenderToken && isManualVisibleForRender_()) {
            scheduleManualRender_("retry:" + reason);
          }
        }, 120);
        return;
      }

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (token !== _manualRenderToken) return;
          if (!isManualVisibleForRender_()) return;
          renderManual(_manualCache.grid, _manualCache.flat);
        });
      });
    };

    requestAnimationFrame(() => step(0));
  }

  function mulPx_(v, k) {
    const n = parseFloat(String(v ?? "").replace("px", ""));
    if (!isFinite(n)) return null;
    return `${Math.max(1, Math.round(n * k))}px`;
  }

  function mulPadding_(pad, k) {
    const parts = String(pad ?? "").trim().split(/\s+/);
    if (!parts.length) return null;
    const out = parts.map(p => mulPx_(p, k) ?? p);
    return out.join(" ");
  }

  function applyCellStyle(td, style, zoomK) {
    if (!style || typeof style !== "object") return;

    const defaultBorder =
      getComputedStyle(document.documentElement)
        .getPropertyValue("--sheet-grid")
        .trim() || "rgba(185,185,185,0.65)";

    if (style.background) td.style.background = style.background;
    if (style.color) td.style.color = style.color;
    if (style.fontSize) td.style.fontSize = mulPx_(style.fontSize, zoomK) || style.fontSize;

    if (style.fontWeight) td.style.fontWeight = style.fontWeight;
    if (style.fontStyle) td.style.fontStyle = style.fontStyle;
    if (style.textAlign) td.style.textAlign = style.textAlign;
    if (style.verticalAlign) td.style.verticalAlign = style.verticalAlign;

    const ws = style.whiteSpace;
    td.style.whiteSpace = (ws === "pre" ? "pre-wrap" : (ws || "pre-wrap"));
    td.style.wordBreak = "break-word";
    td.style.overflow = "visible";
    td.style.textOverflow = "clip";
    td.style.lineHeight = "1.32";

    if (style.padding) td.style.padding = mulPadding_(style.padding, zoomK) || style.padding;

    td.style.borderTop    = style.borderTop    || `1px solid ${defaultBorder}`;
    td.style.borderBottom = style.borderBottom || `1px solid ${defaultBorder}`;
    td.style.borderLeft   = style.borderLeft   || `1px solid ${defaultBorder}`;
    td.style.borderRight  = style.borderRight  || `1px solid ${defaultBorder}`;
  }

  function buildManualTableFromGrid(grid) {
    const rowsTotal = Math.max(0, Number(grid?.rows ?? 0));
    const colsTotal = Math.max(0, Number(grid?.cols ?? 0));
    const cells = Array.isArray(grid?.cells) ? grid.cells : [];

    const cellMap = new Map();
    const covered = new Set();

    for (const cell of cells) {
      const r = Number(cell?.r ?? 0);
      const c = Number(cell?.c ?? 0);
      const rs = Math.max(1, Number(cell?.rowSpan ?? 1));
      const cs = Math.max(1, Number(cell?.colSpan ?? 1));
      const key = `${r},${c}`;

      cellMap.set(key, { r, c, rowSpan: rs, colSpan: cs, text: cell?.text ?? "", style: cell?.style ?? {} });

      for (let rr = r; rr < r + rs; rr++) {
        for (let cc = c; cc < c + cs; cc++) {
          if (rr === r && cc === c) continue;
          covered.add(`${rr},${cc}`);
        }
      }
    }

    if (cellMap.size === 0) {
      const wrap = document.createElement("div");
      wrap.className = "manual-sheet-wrap";
      wrap.innerHTML = "<div class='empty-state' style='min-height:220px;'><div><div class='icon'>ğŸ“˜</div><div class='title'>ì„¤ëª…ì„œ(ê·¸ë¦¬ë“œ)ê°€ ë¹„ì–´ ìˆì–´ìš”</div><div class='desc'>ì‹œíŠ¸ì˜ Manual ì˜ì—­ì„ í™•ì¸í•´ ì£¼ì„¸ìš”.</div></div></div>";
      return wrap;
    }

    const values = [...cellMap.values()];
    const textCells = values.filter(v => String(v?.text ?? "").trim() !== "");
    const basis = textCells.length ? textCells : values;

    let minR = Infinity, minC = Infinity, maxR = -1, maxC = -1;
    for (const v of basis) {
      minR = Math.min(minR, v.r);
      minC = Math.min(minC, v.c);
      maxR = Math.max(maxR, v.r + v.rowSpan - 1);
      maxC = Math.max(maxC, v.c + v.colSpan - 1);
    }

    const PAD_ROWS = 1;
    const PAD_COLS = 0;

    minR = Math.max(0, minR - PAD_ROWS);
    minC = Math.max(0, minC - PAD_COLS);
    maxR = Math.min(rowsTotal - 1, maxR + PAD_ROWS);
    maxC = Math.min(colsTotal - 1, maxC + PAD_COLS);

    const wrap = document.createElement("div");
    wrap.className = "manual-sheet-wrap";

    const table = document.createElement("table");
    table.className = "manual-sheet";
    table.style.tableLayout = "fixed";

    const visibleCols = Math.max(1, (maxC - minC + 1));

    const EMPTY_MIN = 22;
    const TEXT_MIN  = 84;

    const score = new Array(visibleCols).fill(0);
    const hasText = new Array(visibleCols).fill(false);

    for (const v of values) {
      const text = String(v?.text ?? "").trim();
      if (!text) continue;

      const start = Math.max(minC, v.c);
      const end = Math.min(maxC, v.c + (v.colSpan || 1) - 1);
      const per = Math.ceil(text.length / Math.max(1, v.colSpan || 1));

      for (let c = start; c <= end; c++) {
        const idx = c - minC;
        hasText[idx] = true;
        score[idx] = Math.max(score[idx], per);
      }
    }

    const widths = new Array(visibleCols).fill(0);
    let baseSum = 0;
    for (let i = 0; i < visibleCols; i++) {
      widths[i] = hasText[i] ? TEXT_MIN : EMPTY_MIN;
      baseSum += widths[i];
    }

    const manualList = document.getElementById("manualList");
    const cwRaw = Number(manualList?.clientWidth ?? 0) || 0;
    const cw = Math.max(360, cwRaw);

    const CAP_W = isMobile_() ? 9999 : Math.min(720, cw - 24);
    const targetW = Math.min(CAP_W, Math.max(360, cw - (isMobile_() ? 16 : 40)));

    let remain = targetW - baseSum;

    if (remain > 0) {
      const wSum = score.reduce((a, b, i) => a + (hasText[i] ? Math.pow(Math.max(1, b), 0.8) : 0), 0);
      if (wSum > 0) {
        for (let i = 0; i < visibleCols; i++) {
          if (!hasText[i]) continue;
          const w = Math.pow(Math.max(1, score[i]), 0.8);
          widths[i] += Math.floor(remain * (w / wSum));
        }
      }
    }

    const colgroup = document.createElement("colgroup");
    for (let i = 0; i < visibleCols; i++) {
      const col = document.createElement("col");
      col.style.width = `${widths[i]}px`;
      colgroup.appendChild(col);
    }
    table.appendChild(colgroup);

    const sumW = widths.reduce((a, b) => a + b, 0);
    table.style.width = `${sumW}px`;
    table.style.minWidth = "0";

    const tbody = document.createElement("tbody");
    const zoomK = isMobile_() ? MANUAL_ZOOM_MOBILE : MANUAL_ZOOM_DESKTOP;

    for (let r = minR; r <= maxR; r++) {
      const tr = document.createElement("tr");

      for (let c = minC; c <= maxC; c++) {
        const key = `${r},${c}`;
        if (covered.has(key)) continue;

        const data = cellMap.get(key) || { text: "", style: {}, rowSpan: 1, colSpan: 1 };
        const td = document.createElement("td");

        if (data.rowSpan > 1) td.rowSpan = data.rowSpan;
        if (data.colSpan > 1) td.colSpan = data.colSpan;

        td.textContent = data.text ?? "";
        applyCellStyle(td, data.style, zoomK);

        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    wrap.appendChild(table);
    return wrap;
  }

  function renderManual(manualGrid, manualFlat) {
    const list = document.getElementById("manualList");
    if (!list) return;

    list.innerHTML = "";

    if (manualGrid && manualGrid.rows && manualGrid.cols) {
      try {
        list.appendChild(buildManualTableFromGrid(manualGrid));
        scheduleCardSync_();
        return;
      } catch (e) {
        console.error("manualGrid render failed:", e);
      }
    }

    const manual = Array.isArray(manualFlat) ? manualFlat : [];
    if (manual.length === 0) {
      list.innerHTML =
        "<div class='empty-state'><div><div class='icon'>ğŸ“˜</div><div class='title'>ì„¤ëª…ì„œê°€ ë¹„ì–´ ìˆì–´ìš”</div><div class='desc'>ì‹œíŠ¸ì—ì„œ Manual ì˜ì—­ì„ ì±„ìš°ë©´ ì—¬ê¸°ì— í‘œì‹œë¼ìš”.</div></div></div>";
      scheduleCardSync_();
      return;
    }

    const wrap = document.createElement("div");
    wrap.className = "manual-sheet-wrap";

    const div = document.createElement("div");
    div.style.padding = "8px";

    manual.forEach((m) => {
      const line = document.createElement("div");
      const st = m?.style || {};
      line.textContent = m?.text ?? "";
      line.style.whiteSpace = "pre-wrap";
      line.style.padding = "8px 10px";
      line.style.border = "1px solid rgba(185,185,185,0.45)";
      line.style.borderRadius = "10px";
      line.style.marginBottom = "8px";
      line.style.background = st.background || "rgba(255,255,255,0.98)";
      if (st.fontSize) line.style.fontSize = st.fontSize + "px";
      if (st.bold) line.style.fontWeight = "800";
      if (st.color) line.style.color = st.color;
      div.appendChild(line);
    });

    wrap.appendChild(div);
    list.appendChild(wrap);
    scheduleCardSync_();
  }

  // =========================
  // âœ… Songbook load (ETag + ìµœì†Œ ì‘ì—…)
  // =========================
  async function loadSheet(showStatusText = true) {
    if (state.loading) return;
    state.loading = true;

    const songListEl = document.getElementById("songList");
    const songEmptyMessage = document.getElementById("songEmptyMessage");

    if (showStatusText) {
      updateSheetStatus("ë™ê¸°í™” ì¤‘...");
      songListEl.innerHTML =
        "<div class='empty-state'><div><div class='icon'>â³</div><div class='title'>ë¡œë”© ì¤‘â€¦</div><div class='desc'>ì‹œíŠ¸ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ê³  ìˆì–´ìš”.</div></div></div>";
      songEmptyMessage.style.display = "none";
    }

    try {
      const headers = {};
      if (state.songbookEtag) headers["If-None-Match"] = state.songbookEtag;

      const res = await fetch(API_URL, { headers });
      if (res.status === 304) {
        // ë³€ê²½ ì—†ìŒ â†’ UI ì¬ë Œë” ë¶ˆí•„ìš”
        updateSheetStatus("ìµœì‹  ìƒíƒœ(ë³€ê²½ ì—†ìŒ)");
        return;
      }

      if (!res.ok) throw new Error("API HTTP " + res.status);

      const etag = res.headers.get("etag");
      if (etag) state.songbookEtag = etag;

      const data = await res.json();
      const apiSongs = Array.isArray(data.songs) ? data.songs : [];

      const prevNowKey =
        state.nowPlayingId != null
          ? songKey(state.songs.find((s) => s.id === state.nowPlayingId) || {})
          : null;

      const songs = apiSongs
        .map((item, idx) => apiSongToSong(item, idx))
        .filter((s) => s.title && s.title.trim());

      state.songs = songs;
      state.songByKey = new Map();
      for (const s of state.songs) state.songByKey.set(songKey(s), s);

      // âœ… queueê°€ ì´ë¯¸ ìˆìœ¼ë©´ ìƒíƒœ ì¬ì ìš© (ì „ì²´ ìŠ¤ìº” X: queue.items ê¸°ì¤€)
      if (state.lastQueue) {
        const q = normalizeQueue_(state.lastQueue);
        // ì´ˆê¸°í™”
        for (const s of state.songs) { s.requestStatus = "none"; s.requestOrder = null; }
        // queue.itemsë§Œ ìˆœíšŒ
        for (const k in q.items) {
          const song = state.songByKey.get(k);
          if (!song) continue;
          const it = q.items[k];
          song.requestStatus = (String(it.status) === "done") ? "done" : "pending";
          song.requestOrder = Number(it.order ?? null);
        }
        // nowPlaying remap
        const nowKey = String(q.nowPlayingKey ?? "") || null;
        const np = nowKey ? state.songByKey.get(nowKey) : null;
        state.nowPlayingId = np ? np.id : null;
        state.nextRequestOrder = Number(q.nextOrder ?? state.nextRequestOrder ?? 1) || 1;
      }

      rebuildFilterOptions();

      cacheManual_(data.manualGrid, data.manual);
      if (isManualVisibleForRender_()) scheduleManualRender_("loadSheet");

      if (songs.length === 0) {
        songListEl.innerHTML = "";
        songEmptyMessage.style.display = "block";
        updateSheetStatus("ì™„ë£Œ (ê³¡ ì—†ìŒ)");
      } else {
        songEmptyMessage.style.display = "none";
        updateSheetStatus("ìµœì‹  ìƒíƒœ (" + songs.length + "ê³¡)");
      }

      // âœ… ì „ì²´ ë Œë”ëŠ” ì—¬ê¸°ì„œ 1íšŒ(Chunk)
      renderAll();
    } catch (err) {
      console.error(err);
      updateSheetStatus("ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨");
      songEmptyMessage.style.display = "block";
      document.getElementById("songList").innerHTML = "";
      const manualList = document.getElementById("manualList");
      if (manualList) {
        manualList.innerHTML =
          "<div class='empty-state'><div><div class='icon'>âš ï¸</div><div class='title'>ì„¤ëª…ì„œë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆì–´ìš”</div><div class='desc'>ë„¤íŠ¸ì›Œí¬/ì‹œíŠ¸ ìƒíƒœë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.</div></div></div>";
      }
    } finally {
      state.loading = false;
      scheduleCardSync_();
    }
  }

  function getFilteredSongs() {
    const q = normalizeText(state.search);
    const f = String(state.filter || "all");

    return state.songs.filter((song) => {
      if (f === "requested" && song.requestStatus !== "pending") return false;
      if (f === "unrequested" && song.requestStatus !== "none") return false;

      if (f.startsWith("cat:")) {
        const want = f.slice(4);
        if (want !== "__all__") {
          const have = String(song?.category ?? "").trim();
          if (have !== want) return false;
        }
      }

      if (!q) return true;

      const haystack =
        normalizeText(song.title) + " " +
        normalizeText(song.artistRaw) + " " +
        normalizeText(song.artistTags.join(" ")) + " " +
        normalizeText(song.category) + " " +
        normalizeText(song.tags.join(" ")) + " " +
        normalizeText(song.flagTags.join(" "));

      return haystack.includes(q);
    });
  }

  function createSongRow_(song) {
    const row = document.createElement("article");
    const key = songKey(song);
    row.className = "song-row" + (song.requestStatus === "pending" ? " requested" : "");
    row.dataset.songKey = key;
    row.dataset.songId = song.id;

    const main = document.createElement("div");
    main.className = "song-main";

    const titleEl = document.createElement("div");
    titleEl.className = "song-title";
    titleEl.textContent = song.title;
    main.appendChild(titleEl);

    const meta = document.createElement("div");
    meta.className = "song-meta";

    if (song.category) {
      const cat = document.createElement("span");
      cat.className = "tag";
      cat.textContent = song.category;
      applyCategoryClassToTag(cat, song.category);
      meta.appendChild(cat);
    }

    (song.artistTags || []).forEach((a) => {
      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = a;
      applyCategoryClassToTag(tag, a);
      meta.appendChild(tag);
    });

    (song.tags || []).forEach((t) => {
      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = t;
      applyCategoryClassToTag(tag, t);
      meta.appendChild(tag);
    });

    (song.flagTags || []).forEach((f) => {
      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = f;
      applyCategoryClassToTag(tag, f);
      meta.appendChild(tag);
    });

    if (song.url) {
      const tag = document.createElement("span");
      tag.className = "tag";
      tag.style.background = "rgba(243,166,91,.92)";
      tag.style.borderColor = "rgba(243,166,91,.92)";
      tag.style.color = "#fff";
      tag.textContent = "â–¶";
      meta.appendChild(tag);
    }

    main.appendChild(meta);

    const actions = document.createElement("div");
    actions.className = "song-actions";

    const statusPill = document.createElement("span");
    statusPill.className = "song-status-pill";
    if (song.requestStatus === "pending") statusPill.textContent = "ì‹ ì²­ë¨";
    else if (song.requestStatus === "done") statusPill.textContent = "ì™„ë£Œ";
    else statusPill.textContent = "";
    if (!statusPill.textContent) statusPill.style.display = "none";

    actions.appendChild(statusPill);

    const btn = document.createElement("button");
    btn.className = "song-btn";
    btn.textContent = song.requestStatus === "pending" ? "ì·¨ì†Œ" : "ì‹ ì²­";
    btn.addEventListener("click", () => requireAuthThen(() => toggleRequest(song.id)));

    actions.appendChild(btn);

    row.appendChild(main);
    row.appendChild(actions);

    domCache.songRowByKey.set(key, { row, statusEl: statusPill, btnEl: btn });
    return row;
  }

  // âœ… í•µì‹¬: 2000~5000ê³¡ë„ ë©ˆì¶”ì§€ ì•Šê²Œ chunk ë Œë”
  function renderSongsFull_() {
    const container = document.getElementById("songList");
    const list = getFilteredSongs();
    const token = ++state.songRenderToken;

    domCache.songRowByKey.clear();
    container.innerHTML = "";

    if (!list.length) {
      container.innerHTML =
        "<div class='empty-state'><div><div class='icon'>ğŸ”</div><div class='title'>ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ì–´ìš”</div><div class='desc'>í‚¤ì›Œë“œë¥¼ ë°”ê¾¸ê±°ë‚˜ í•„í„°ë¥¼ â€˜ì „ì²´ ë³´ê¸°â€™ë¡œ ë°”ê¿”ë³´ì„¸ìš”.</div></div></div>";
      scheduleCardSync_();
      return;
    }

    let i = 0;
    const CHUNK = 140;

    const step = () => {
      if (token !== state.songRenderToken) return;

      const frag = document.createDocumentFragment();
      for (let n = 0; n < CHUNK && i < list.length; n++, i++) {
        frag.appendChild(createSongRow_(list[i]));
      }
      container.appendChild(frag);

      if (i < list.length) requestAnimationFrame(step);
      else scheduleCardSync_();
    };

    requestAnimationFrame(step);
  }

  // =========================
  // âœ… Requests: queue.itemsë§Œ ìˆœíšŒ (O(M))
  // =========================
  function getRequestedSongsFromQueue_(tab) {
    const q = normalizeQueue_(state.lastQueue);
    const items = q.items;
    const arr = [];

    for (const k in items) {
      const it = items[k];
      const st = (String(it.status) === "done") ? "done" : "pending";
      if (st !== tab) continue;

      const song = state.songByKey.get(k);
      if (!song) continue;

      arr.push({ song, order: Number(it.order ?? 0) || 0, key: k });
    }

    arr.sort((a, b) => (a.order - b.order) || (a.key < b.key ? -1 : 1));
    return arr.map(x => x.song);
  }

  function renderRequests() {
    const listEl = document.getElementById("requestList");
    const tab = state.requestTab;

    const songs = getRequestedSongsFromQueue_(tab);

    listEl.innerHTML = "";

    if (!songs.length) {
      const label = tab === "pending" ? "ëŒ€ê¸° ì¤‘ì¸ ì‹ ì²­ê³¡ì´ ì—†ì–´ìš”" : "ì™„ë£Œëœ ê³¡ì´ ì•„ì§ ì—†ì–´ìš”";
      const desc  = tab === "pending"
        ? "ì™¼ìª½ ë…¸ë˜ ëª©ë¡ì—ì„œ â€˜ì‹ ì²­â€™ì„ ëˆ„ë¥´ë©´ ì—¬ê¸°ì— ìŒ“ì—¬ìš”."
        : "ëŒ€ê¸° ëª©ë¡ì—ì„œ â€˜ì§€ê¸ˆ ë¶€ë¥´ê¸°â€™ â†’ â€˜ë…¸ë˜ ì™„ë£Œâ€™ë¡œ ì´ë™ë¼ìš”.";

      listEl.innerHTML =
        "<div class='empty-state'><div><div class='icon'>ğŸ’Œ</div><div class='title'>" + label + "</div><div class='desc'>" + desc + "</div></div></div>";
      scheduleCardSync_();
      return;
    }

    songs.forEach((song) => {
      const row = document.createElement("article");
      row.className = "song-row requested";

      const main = document.createElement("div");
      main.className = "song-main";

      const title = document.createElement("div");
      title.className = "song-title";
      title.textContent = song.title;
      main.appendChild(title);

      const meta = document.createElement("div");
      meta.className = "song-meta";

      if (song.category) {
        const cat = document.createElement("span");
        cat.className = "tag";
        cat.textContent = song.category;
        applyCategoryClassToTag(cat, song.category);
        meta.appendChild(cat);
      }

      (song.artistTags || []).forEach((a) => {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = a;
        applyCategoryClassToTag(tag, a);
        meta.appendChild(tag);
      });

      (song.flagTags || []).forEach((f) => {
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = f;
        applyCategoryClassToTag(tag, f);
        meta.appendChild(tag);
      });

      main.appendChild(meta);

      const actions = document.createElement("div");
      actions.className = "song-actions";

      const status = document.createElement("span");
      status.className = "song-status-pill";
      status.textContent = tab === "pending" ? "Waiting" : "Done";
      actions.appendChild(status);

      if (tab === "pending") {
        const btnPlay = document.createElement("button");
        btnPlay.className = "song-btn";
        btnPlay.style.background = "var(--primary)";
        btnPlay.style.color = "#fff";
        btnPlay.textContent = "ì§€ê¸ˆ ë¶€ë¥´ê¸°";
        btnPlay.addEventListener("click", () => requireAuthThen(() => setNowPlaying(song.id)));
        actions.appendChild(btnPlay);
      }

      row.appendChild(main);
      row.appendChild(actions);
      listEl.appendChild(row);
    });

    scheduleCardSync_();
  }

  function renderNowPlaying() {
    const card = document.getElementById("nowPlayingCard");
    const titleEl = document.getElementById("nowPlayingTitle");
    const metaEl = document.getElementById("nowPlayingMeta");
    const btnDone = document.getElementById("nowPlayingDoneBtn");

    const song =
      state.nowPlayingId != null
        ? state.songs.find((s) => s.id === state.nowPlayingId)
        : null;

    if (!song) {
      card.classList.add("empty");
      titleEl.textContent = "ì„ íƒëœ ê³¡ ì—†ìŒ";
      metaEl.textContent = "ëŒ€ê¸° ëª©ë¡ì—ì„œ 'ì§€ê¸ˆ ë¶€ë¥´ê¸°'ë¥¼ ì„ íƒí•˜ì„¸ìš”.";
      btnDone.disabled = true;
      scheduleCardSync_();
      return;
    }

    card.classList.remove("empty");
    titleEl.textContent = song.title;
    metaEl.textContent = "ğŸ¤ On Stage";
    btnDone.disabled = false;
    scheduleCardSync_();
  }

  function renderAll() {
    renderSongsFull_();
    renderRequests();
    renderNowPlaying();
    scheduleCardSync_();
  }

  async function toggleRequest(songId) {
    const song = state.songs.find((s) => s.id === songId);
    if (!song) return;
    try {
      await queueAction("toggle", songKey(song));
    } catch (e) {
      alert("ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨: " + (e?.message || "error"));
    }
  }

  async function setNowPlaying(songId) {
    const song = state.songs.find((s) => s.id === songId);
    if (!song) return;
    try {
      await queueAction("nowPlaying", songKey(song));
    } catch (e) {
      alert("ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨: " + (e?.message || "error"));
    }
  }

  async function markNowPlayingDone() {
    try {
      await queueAction("done", "");
    } catch (e) {
      alert("ì™„ë£Œ ì²˜ë¦¬ ì‹¤íŒ¨: " + (e?.message || "error"));
    }
  }

  async function clearRequests() {
    try {
      await queueAction("clear", "");
    } catch (e) {
      alert("ì´ˆê¸°í™” ì‹¤íŒ¨: " + (e?.message || "error"));
    }
  }

  function initWheelBlocks_() {
    blockHorizontalWheel(document.getElementById("songList"));
    blockHorizontalWheel(document.getElementById("requestList"));
    blockHorizontalWheel(document.getElementById("manualList"));
  }

  function setManualCollapsed_(collapsed) {
    const badge = document.getElementById("manualToggleBadge");
    if (!isMobile_()) {
      document.body.classList.remove("manual-collapsed");
      if (badge) badge.setAttribute("aria-expanded", "true");
      return;
    }
    document.body.classList.toggle("manual-collapsed", !!collapsed);
    if (badge) badge.setAttribute("aria-expanded", collapsed ? "false" : "true");
    if (!collapsed) scheduleManualRender_("mobileExpand");
  }

  function setManualHiddenDesktop_(hidden) {
    const isMob = isMobile_();
    const guideBtn = document.getElementById("guideToggleBtn");
    const badge = document.getElementById("manualToggleBadge");

    if (isMob) {
      document.body.classList.remove("manual-hidden");
      if (guideBtn) {
        guideBtn.textContent = document.body.classList.contains("manual-collapsed") ? "ğŸ“˜ ê°€ì´ë“œ í¼ì¹˜ê¸°" : "ğŸ“˜ ê°€ì´ë“œ ì ‘ê¸°";
        guideBtn.setAttribute("aria-pressed", document.body.classList.contains("manual-collapsed") ? "true" : "false");
      }
      if (badge) badge.textContent = "Manual";
      return;
    }

    const wasHidden = document.body.classList.contains("manual-hidden");

    document.body.classList.toggle("manual-hidden", !!hidden);
    state.manualHiddenDesktop = !!hidden;

    if (guideBtn) {
      guideBtn.textContent = hidden ? "ğŸ“˜ ê°€ì´ë“œ ë³´ì´ê¸°" : "ğŸ“˜ ê°€ì´ë“œ ìˆ¨ê¹€";
      guideBtn.setAttribute("aria-pressed", hidden ? "true" : "false");
    }

    if (badge) badge.textContent = "Manual";

    if (wasHidden && !hidden) scheduleManualRender_("desktopShow");
    scheduleCardSync_();
  }

  function toggleGuide_() {
    if (isMobile_()) {
      const collapsed = !document.body.classList.contains("manual-collapsed");
      setManualCollapsed_(collapsed);
      try { localStorage.setItem("mone_manual_collapsed_mobile", collapsed ? "1" : "0"); } catch(_) {}
      setManualHiddenDesktop_(false);
      scheduleCardSync_();
      return;
    }

    const hidden = !document.body.classList.contains("manual-hidden");
    setManualHiddenDesktop_(hidden);
    try { localStorage.setItem("mone_manual_hidden_desktop", hidden ? "1" : "0"); } catch(_) {}
    scheduleCardSync_();
  }

  /* =========================================================
     âœ… ì¹´ë“œ ë†’ì´ ë™ê¸°í™”(ë°ìŠ¤í¬í†±ë§Œ)
     ========================================================= */
  let _cardSyncRaf = 0;

  function scheduleCardSync_() {
    if (_cardSyncRaf) return;
    _cardSyncRaf = requestAnimationFrame(() => {
      _cardSyncRaf = 0;
      syncCardHeights_();
    });
  }

  function syncCardHeights_() {
    const manual = document.getElementById("manualCard");
    const songs  = document.getElementById("songsCard");
    const req    = document.getElementById("requestsCard");
    if (!songs || !req) return;

    if (isMobile_()) {
      if (manual) manual.style.height = "";
      songs.style.height = "";
      req.style.height = "";
      return;
    }

    if (manual) manual.style.height = "";
    songs.style.height = "";
    req.style.height = "";

    const CAP = 950;
    const h0 = Math.ceil(req.getBoundingClientRect().height);
    const h = Math.min(CAP, h0);
    if (!h) return;

    const px = `${h}px`;
    req.style.height = px;
    songs.style.height = px;

    if (manual && !document.body.classList.contains("manual-hidden")) {
      manual.style.height = px;
    }
  }

  // =========================
  // âœ… Queue polling (ê°€ë³€ + íƒ­ ìˆ¨ê¹€ ëŠë¦¬ê²Œ)
  // =========================
  let _queuePollTimer = null;

  function getQueuePollMs_() {
    if (document.hidden) return 30000;
    return state.authenticated ? 4000 : 8000;
  }

  function stopQueuePolling_() {
    if (_queuePollTimer) clearTimeout(_queuePollTimer);
    _queuePollTimer = null;
  }

  function startQueuePolling_(opts = {}) {
    const immediate = !!opts.immediate;
    stopQueuePolling_();

    if (immediate) loadQueueOnce({ force: true }).catch(() => {});
    const tick = async () => {
      await loadQueueOnce();
      _queuePollTimer = setTimeout(tick, getQueuePollMs_());
    };
    _queuePollTimer = setTimeout(tick, getQueuePollMs_());
  }

  window.addEventListener("DOMContentLoaded", async () => {
    const searchInput = document.getElementById("searchInput");
    const filterSelect = document.getElementById("filterSelect");
    const viewToggle = document.getElementById("viewToggle");
    const reloadBtn = document.getElementById("reloadBtn");
    const requestTabToggle = document.getElementById("requestTabToggle");
    const clearRequestsBtn = document.getElementById("clearRequestsBtn");
    const nowPlayingDoneBtn = document.getElementById("nowPlayingDoneBtn");

    const loginBtn = document.getElementById("loginBtn");
    const pwChangeBtn = document.getElementById("pwChangeBtn");
    const logoutBtn = document.getElementById("logoutBtn");

    const bd = document.getElementById("authModalBackdrop");
    const closeBtn = document.getElementById("authModalCloseBtn");
    const cancelBtn = document.getElementById("authCancelBtn");
    const okBtn = document.getElementById("authOkBtn");

    const manualToggleBadge = document.getElementById("manualToggleBadge");
    const guideToggleBtn = document.getElementById("guideToggleBtn");

    initWheelBlocks_();

    try {
      const m1 = localStorage.getItem("mone_manual_hidden_desktop");
      const m2 = localStorage.getItem("mone_manual_collapsed_mobile");
      if (m2 === "1") document.body.classList.add("manual-collapsed");
      if (m1 === "1") document.body.classList.add("manual-hidden");
    } catch(_) {}

    setManualHiddenDesktop_(document.body.classList.contains("manual-hidden"));
    hookFontsReadyOnce_();

    await checkAuth();

    // âœ… queue í´ë§ ì‹œì‘
    startQueuePolling_({ immediate: true });

    document.addEventListener("visibilitychange", () => {
      startQueuePolling_({ immediate: !document.hidden });
    });
    window.addEventListener("focus", () => startQueuePolling_({ immediate: true }));
    window.addEventListener("blur", () => startQueuePolling_({ immediate: false }));

    if (manualToggleBadge) {
      const toggle = () => toggleGuide_();
      manualToggleBadge.addEventListener("click", toggle);
      manualToggleBadge.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggle(); }
      });
    }
    if (guideToggleBtn) guideToggleBtn.addEventListener("click", toggleGuide_);

    window.addEventListener("resize", () => {
      if (isMobile_()) {
        document.body.classList.remove("manual-hidden");
        setManualHiddenDesktop_(false);
      } else {
        setManualHiddenDesktop_(document.body.classList.contains("manual-hidden"));
        document.body.classList.remove("manual-collapsed");
      }

      if (isManualVisibleForRender_()) scheduleManualRender_("resize");
      scheduleCardSync_();
    });

    if (loginBtn) loginBtn.addEventListener("click", () => { state.pendingAction = null; openAuthModal("login"); });
    if (pwChangeBtn) pwChangeBtn.addEventListener("click", () => { state.pendingAction = null; openAuthModal("change"); });

    if (logoutBtn) {
      logoutBtn.addEventListener("click", async () => {
        const ok = confirm("ë¡œê·¸ì•„ì›ƒí• ê¹Œìš”?");
        if (!ok) return;
        const done = await doLogout();
        if (!done) alert("ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨");
      });
    }

    function onCloseModal() {
      closeAuthModal();
      state.pendingAction = null;
    }
    if (closeBtn) closeBtn.addEventListener("click", onCloseModal);
    if (cancelBtn) cancelBtn.addEventListener("click", onCloseModal);
    if (bd) {
      bd.addEventListener("click", (e) => {
        if (e.target === bd) onCloseModal();
      });
    }

    if (okBtn) {
      okBtn.addEventListener("click", async () => {
        const err = document.getElementById("authModalError");
        if (err) { err.style.display = "none"; err.textContent = ""; }

        if (state.authMode === "login") {
          const pw = document.getElementById("loginPassword")?.value || "";
          if (!pw.trim()) return showAuthError("ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì¤˜.");
          const r = await doLogin(pw);
          if (!r.ok) return showAuthError("ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•Šì•„.");
          closeAuthModal();

          const act = state.pendingAction;
          state.pendingAction = null;
          if (typeof act === "function") {
            try { await act(); } catch (e) { alert("ì‘ì—… ì‹¤íŒ¨: " + (e?.message || "error")); }
          }
          scheduleCardSync_();
          return;
        }

        const cur = document.getElementById("currentPassword")?.value || "";
        const np1 = document.getElementById("newPassword")?.value || "";
        const np2 = document.getElementById("newPassword2")?.value || "";

        if (!cur.trim()) return showAuthError("í˜„ì¬ ë¹„ë°€ë²ˆí˜¸(ë˜ëŠ” ë§ˆìŠ¤í„°)ë¥¼ ì…ë ¥í•´ì¤˜.");
        if (!np1.trim() || np1.length < 4) return showAuthError("ìƒˆ ë¹„ë°€ë²ˆí˜¸ëŠ” 4ì ì´ìƒì´ì–´ì•¼ í•´.");
        if (np1 !== np2) return showAuthError("ìƒˆ ë¹„ë°€ë²ˆí˜¸ í™•ì¸ì´ ì¼ì¹˜í•˜ì§€ ì•Šì•„.");

        const r = await doChangePassword(cur, np1);
        if (!r.ok) {
          if (r.code === "reserved") return showAuthError("ì´ ë¹„ë°€ë²ˆí˜¸ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ì–´.");
          if (r.code === "invalid") return showAuthError("í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•Šì•„.");
          return showAuthError("ë³€ê²½ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì¤˜.");
        }

        alert("ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ëì–´.");
        closeAuthModal();
        scheduleCardSync_();
      });
    }

    // âœ… ê²€ìƒ‰/í•„í„°ëŠ” ìì£¼ ë°œìƒí•˜ë¯€ë¡œ ì‚´ì§ ë””ë°”ìš´ìŠ¤ + chunk ë Œë”
    let _searchTimer = 0;
    searchInput.addEventListener("input", (e) => {
      state.search = e.target.value || "";
      clearTimeout(_searchTimer);
      _searchTimer = setTimeout(() => renderSongsFull_(), 120);
    });

    filterSelect.addEventListener("change", (e) => {
      state.filter = e.target.value;
      renderSongsFull_();
      scheduleCardSync_();
    });

    viewToggle.querySelectorAll(".toggle").forEach((el) => {
      el.addEventListener("click", () => {
        viewToggle.querySelectorAll(".toggle").forEach((t) => t.classList.remove("active"));
        el.classList.add("active");
        const mode = el.dataset.mode || "list";
        state.viewMode = mode;
        if (mode === "compact") document.body.classList.add("compact-mode");
        else document.body.classList.remove("compact-mode");
        scheduleCardSync_();
      });
    });

    reloadBtn.addEventListener("click", () => {
      loadSheet(false);
      scheduleCardSync_();
    });

    requestTabToggle.querySelectorAll(".toggle").forEach((el) => {
      el.addEventListener("click", () => {
        requestTabToggle.querySelectorAll(".toggle").forEach((t) => t.classList.remove("active"));
        el.classList.add("active");
        state.requestTab = el.dataset.tab || "pending";
        renderRequests();
        scheduleCardSync_();
      });
    });

    clearRequestsBtn.addEventListener("click", () => {
      requireAuthThen(async () => {
        if (!confirm("ëª¨ë“  ì‹ ì²­ ê³¡ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
        await clearRequests();
        scheduleCardSync_();
      });
    });

    nowPlayingDoneBtn.addEventListener("click", () => {
      requireAuthThen(async () => {
        await markNowPlayingDone();
        scheduleCardSync_();
      });
    });

    // âœ… ì´ˆê¸° ë¡œë“œ + 30ì´ˆ ì£¼ê¸° ê°±ì‹ 
    loadSheet(true);
    setInterval(() => loadSheet(false), 30000);

    scheduleCardSync_();
  });
</script>
</body>
</html>
